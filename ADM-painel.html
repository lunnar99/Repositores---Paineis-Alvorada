<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Painel ADM</title>
    <link rel="stylesheet" href="adm.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="icon" href="/logo/LOGO ADM.png" type="image/png">
    <style>
      
    </style>
</head>

<body onload="initADM()">
    <div class="container">
        <header>
            <h1>Painel do Administrador</h1>
        </header>

        <section class="form-section">
            <h2>Adicionar Nova Tag</h2>
            <form id="tagForm">
                <div class="form-group">
                    <label for="img" >Imagem</label>
                    <input type="file" id="img" accept="image/*" multiple required>
                    <small id="fileInfo" class="file-info" aria-live="polite"></small>
    
                </div>

                <!-- Novo campo único de Período -->
                <div class="form-group" style="position:relative; ">
                    <label for="dateRangeDisplay">Período</label>
                    <input type="text" id="dateRangeDisplay" placeholder="Clique e selecione" readonly>
                    <div id="dateRangePicker" class="drp" style="display:none; "></div>
                </div>

                <!-- Campos originais agora ocultos (mantidos para não quebrar o envio) -->
                <div class="form-group" style="display:none;">
                    <label for="start">Data de Início</label>
                    <input type="hidden" id="start" required>
                </div>
                <div class="form-group" style="display:none;">
                    <label for="end">Data de Fim</label>
                    <input type="hidden" id="end" required>
                </div>

                <div class="form-group">
                    <label for="comment">Comentário</label>
                    <textarea id="comment" placeholder="(opcional)"></textarea>
                </div>

                <button id="openFilters" class="btn-filter" type="button"  style="margin-top: 20px;">
                    <i class="fa fa-filter"></i> Filtros
                </button>

                <div id="filtersModal" class="modal" >
                    <div class="modal-content">
                        <span id="closeFilters" class="close">&times;</span>
                        <h2>Filtros</h2>
                        <div class="filter-section">
                            <h3>Lojas</h3>
                            <div id="stores" class="stores-grid"></div>
                        </div>
                        <div style="margin-top: 15px; text-align: right;">
                            <button id="applyFilters" class="btn-apply" type="button">Aplicar</button>
                        </div>
                    </div>
                </div>

                <button type="submit" class="btn-submit" style="margin-top: 20px;">Adicionar</button>
            </form>
        </section>

        <section class="select-section">
            <input type="checkbox" id="selectAll">
            <label for="selectAll">Selecionar todos</label>
            <button id="deleteSelected">Excluir selecionados</button>
            <!-- Botão que abre o modal -->
            <button id="openFilters-tags" class="btn-filter-tags" type="button">
                <i class="fa fa-filter"></i>
            </button>
            <!-- Busca rápida por dia (ex: 7 ou 07 a 10) -->
            <input type="text" id="tagsQuickSearch" placeholder="Buscar por dia (ex: 7 ou 07 a 10)" style="margin-left:10px; padding:6px 10px; border:1px solid #6b8c74; border-radius:8px;">
        </section>

        <!-- Novo Modal de Filtro de Tags (por data e lojas) -->
        <div id="tagsFilterModal" class="modal">
            <div class="modal-content">
                <span id="closeTagsFilters" class="close">&times;</span>
                <h2>Filtrar Tags</h2>

                <div class="filter-section">
                    <h3>Data</h3>
                    <div class="date-row" style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
                        <div style="display:flex;flex-direction:column;">
                            <label for="filterStart">Início</label>
                            <input type="date" id="filterStart">
                        </div>
                        <div style="display:flex;flex-direction:column;">
                            <label for="filterEnd">Fim</label>
                            <input type="date" id="filterEnd">
                        </div>
                        <small style="opacity:.8;">Preencha ambos para combinar início e fim; preencha só um para filtrar por aquele dia.</small>
                    </div>
                </div>

                <div class="filter-section">
                    <h3>Lojas</h3>
                    <div id="tagsFilterStores" class="stores-grid"></div>
                </div>

                <div style="margin-top: 15px; text-align: right;">
                    <button id="clearTagsFilters" class="btn-apply" type="button" style="background:#6c757d;">Limpar</button>
                    <button id="applyTagsFilters" class="btn-apply" type="button">Aplicar</button>
                </div>
            </div>
        </div>

        <main class="tags-grid" id="tagsGrid"></main>
    </div>

    <!-- Overlay de Loading (bloqueia cliques durante upload) -->
    <div id="loadingOverlay" class="loading-overlay" aria-hidden="true">
        <div class="loader" role="status" aria-label="Carregando"></div>
    </div>

    <!-- Firebase -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
    import { getFirestore, collection, addDoc, getDocs, deleteDoc, doc, query, where, setDoc } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-storage.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAjzds2ts_R2gqgN2x0p80xq20-6QSAkjY",
            authDomain: "tags-repositores.firebaseapp.com",
            projectId: "tags-repositores",
            storageBucket: "tags-repositores.firebasestorage.app",
            messagingSenderId: "452823969336",
            appId: "1:452823969336:web:09ce09427ee49f46c880cd",
            measurementId: "G-0BLTNKVWVZ"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const storage = getStorage(app);

        window.db = db;
        window.storage = storage;
        window.collection = collection;
        window.doc = doc;
        window.addDoc = addDoc;
    window.getDocs = getDocs;
        window.deleteDoc = deleteDoc;
    window.setDoc = setDoc;
    window.query = query;
    window.where = where;
        window.ref = ref;
        window.uploadBytes = uploadBytes;
        window.getDownloadURL = getDownloadURL;
    </script>

    <!-- Script ADM -->
    <script type="module">
        // Gate: only ADM can access
        const role = localStorage.getItem('role');
        const user = localStorage.getItem('user');
        if (!role || role !== 'ADM') {
            alert('Acesso restrito ao ADM.');
            window.location.href = 'index.html';
        }

        // Fixed session badge (user + role + logout), similar to user panel
        function createSessionBadge() {
            if (document.getElementById('sessionBadge')) return;
            const badge = document.createElement('div');
            badge.id = 'sessionBadge';
            badge.className = 'session-badge';
            const userLabel = (user || 'sem-usuário');
            const roleLabel = (role || '-');
            badge.innerHTML = `
                <span class="id">${userLabel}</span>
                <span class="sep">•</span>
                <span class="flag">${roleLabel}</span>
                <button type="button" class="logout-btn" title="Sair">Sair</button>
            `;
            document.body.appendChild(badge);
            badge.querySelector('.logout-btn')?.addEventListener('click', () => {
                try {
                    localStorage.removeItem('role');
                    localStorage.removeItem('user');
                } catch(_) {}
                window.location.href = 'index.html';
            });
        }
        createSessionBadge();

        const lojas = ["AGU", "ARA", "ARS", "BAC", "BOT", "BUZ", "CF1", "CF2", "CAS",
            "COL", "COP", "COR", "IGU", "INO", "ITA", "JC", "JE", "MAC",
            "MG1", "MG2", "MAR", "NOV", "RB1", "RB2", "RDO", "SJI",
            "SPD", "TAN", "TRI", "UNA"];

    let tags = [];
    const printedInfoCache = new Map(); // tagId -> [{role, printedAt}]
    const attentionInfoCache = new Map(); // tagId -> Set(role)

        // Novo estado de filtros da visualização
        const viewFilter = { start: null, end: null, stores: [] };

        function renderStores() {
            const storesDiv = document.getElementById("stores");
            if (!storesDiv) return;
            storesDiv.innerHTML = "";
            lojas.forEach(loja => {
                const label = document.createElement("label");
                const cb = document.createElement("input");
                cb.type = "checkbox";
                cb.value = loja;
                label.appendChild(cb);
                label.appendChild(document.createTextNode(loja));
                storesDiv.appendChild(label);
            });
        }
        renderStores();

        function getStatus(start, end) {
            const hoje = new Date();
            hoje.setHours(0, 0, 0, 0);
            const inicio = new Date(start);
            const fim = new Date(end);

            if (!inicio || !fim || isNaN(inicio) || isNaN(fim)) return "expired";
            if (fim < hoje) return "expired";
            if (inicio > hoje) return "soon";

            const diff = Math.ceil((fim - hoje) / (1000 * 60 * 60 * 24));
            if (diff <= 1) return "soon";
            return "valid";
        }

        function formatDate(dateInput) {
            if (!dateInput) return "Data inválida";
            const date = new Date(dateInput);
            if (isNaN(date.getTime())) return "Data inválida";
            const meses = ["JAN", "FEV", "MAR", "ABR", "MAI", "JUN", "JUL", "AGO", "SET", "OUT", "NOV", "DEZ"];
            const dia = String(date.getDate()).padStart(2, "0");
            const mes = meses[date.getMonth()];
            return `${dia} ${mes}`;
        }

        // Helpers para filtro por data
        function parseToDate(val) {
            if (!val) return null;
            if (val instanceof Date) return isNaN(val) ? null : val;
            return new Date(val);
        }
        function isSameDay(a, b) {
            const da = parseToDate(a), db = parseToDate(b);
            if (!da || !db) return false;
            return da.getFullYear() === db.getFullYear() &&
                   da.getMonth() === db.getMonth() &&
                   da.getDate() === db.getDate();
        }
        // Normaliza para data somente (00:00 local)
        function dateOnly(d) {
            const dd = parseToDate(d);
            if (!dd) return null;
            return new Date(dd.getFullYear(), dd.getMonth(), dd.getDate());
        }
        function startOfDay(d) {
            const dd = parseToDate(d);
            if (!dd) return null;
            return new Date(dd.getFullYear(), dd.getMonth(), dd.getDate(), 0, 0, 0, 0);
        }
        function endOfDay(d) {
            const dd = parseToDate(d);
            if (!dd) return null;
            return new Date(dd.getFullYear(), dd.getMonth(), dd.getDate(), 23, 59, 59, 999);
        }

        // -------------------- Date Range Picker (sem libs) --------------------
        const startInput = document.getElementById("start");
        const endInput = document.getElementById("end");
        const rangeInput = document.getElementById("dateRangeDisplay");
        const picker = document.getElementById("dateRangePicker");

        const mesesNome = ["janeiro", "fevereiro", "março", "abril", "maio", "junho", "julho", "agosto", "setembro", "outubro", "novembro", "dezembro"];
        const mesesShort = ["JAN", "FEV", "MAR", "ABR", "MAI", "JUN", "JUL", "AGO", "SET", "OUT", "NOV", "DEZ"];
        let viewDate = new Date();
        viewDate.setDate(1);
        let selStart = null;
        let selEnd = null;

        function toYMDLocal(d) {
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, "0");
            const day = String(d.getDate()).padStart(2, "0");
            return `${y}-${m}-${day}`;
        }
        function fromYMDLocal(s) {
            const [y, m, d] = s.split("-").map(Number);
            return new Date(y, m - 1, d);
        }
        function formatHumanRange(a, b) {
            const dd = (d) => String(d.getDate()).padStart(2, "0");
            return `${dd(a)} ${mesesShort[a.getMonth()]} a ${dd(b)} ${mesesShort[b.getMonth()]}`;
        }

        function openPicker() {
            if (!picker) return;
            // posiciona abaixo do input, relativo ao container (.form-group)
            const rect = rangeInput.getBoundingClientRect();
            const parentRect = rangeInput.parentElement.getBoundingClientRect();
            picker.style.left = `${rect.left - parentRect.left}px`;
            picker.style.top = `${rect.bottom - parentRect.top + 4}px`;
            picker.style.display = "block";
            renderPicker();
        }
        function closePicker() {
            if (picker) picker.style.display = "none";
        }
        function renderPicker() {
            const y = viewDate.getFullYear();
            const m = viewDate.getMonth();
            const firstDay = new Date(y, m, 1);
            const lastDay = new Date(y, m + 1, 0);
            const startDow = firstDay.getDay(); // 0..6 dom..sab
            const total = lastDay.getDate();

            let html = `
              <header>
                <div class="controls">
                  <button type="button" id="drpPrev">&#9664;</button>
                </div>
                <div>${mesesNome[m]} ${y}</div>
                <div class="controls">
                  <button type="button" id="drpNext">&#9654;</button>
                </div>
              </header>
              <div class="grid">
                <div class="dow">D</div><div class="dow">S</div><div class="dow">T</div><div class="dow">Q</div><div class="dow">Q</div><div class="dow">S</div><div class="dow">S</div>
            `;

            for (let i = 0; i < startDow; i++) {
                html += `<div class="day muted"></div>`;
            }
            for (let d = 1; d <= total; d++) {
                const dateObj = new Date(y, m, d);
                const iso = toYMDLocal(dateObj);
                let cls = "day";
                if (selStart && toYMDLocal(selStart) === iso) cls += " selected";
                if (selEnd && toYMDLocal(selEnd) === iso) cls += " selected";
                if (selStart && selEnd && dateObj > selStart && dateObj < selEnd) cls += " in-range";
                html += `<div class="${cls}" data-date="${iso}">${d}</div>`;
            }
            html += `</div>`;
            picker.innerHTML = html;

            picker.querySelector("#drpPrev").onclick = () => { viewDate = new Date(y, m - 1, 1); renderPicker(); };
            picker.querySelector("#drpNext").onclick = () => { viewDate = new Date(y, m + 1, 1); renderPicker(); };

            // ALTERADO: parar a propagação do clique no dia para não disparar o close externo
            picker.querySelectorAll(".day[data-date]").forEach(el => {
                el.addEventListener("click", (ev) => {
                    ev.stopPropagation(); // impede o listener global de fechar ao re-renderizar
                    const d = fromYMDLocal(el.dataset.date);
                    if (!selStart || (selStart && selEnd)) {
                        selStart = d;
                        selEnd = null;
                    } else {
                        if (d < selStart) { selStart = d; selEnd = null; }
                        else { selEnd = d; }
                    }
                    if (selStart && selEnd) {
                        startInput.value = toYMDLocal(selStart);
                        endInput.value = toYMDLocal(selEnd);
                        rangeInput.value = formatHumanRange(selStart, selEnd);
                        closePicker();
                    } else {
                        // re-render após o clique do dia selecionado
                        // (propagação já está parada, não fecha)
                        renderPicker();
                    }
                });
            });
        }

        // Eventos do input e clique fora
        rangeInput?.addEventListener("click", (e) => {
            e.stopPropagation();
            openPicker();
        });
        document.addEventListener("click", (e) => {
            if (!picker || picker.style.display === "none") return;
            const path = typeof e.composedPath === "function" ? e.composedPath() : [];
            const clickedInside = path.includes(picker) || picker.contains(e.target) || e.target === rangeInput;
            if (clickedInside) return;
            closePicker();
        });
        window.addEventListener("resize", () => { if (picker && picker.style.display !== "none") openPicker(); });
        window.addEventListener("scroll", () => {
            if (picker && picker.style.display !== "none") openPicker();
        }, true);

        // Se já houver valores preenchidos (ex.: reabrir tela)
        if (startInput?.value && endInput?.value) {
            selStart = fromYMDLocal(startInput.value);
            selEnd = fromYMDLocal(endInput.value);
            rangeInput.value = formatHumanRange(selStart, selEnd);
        }

        // Adiciona bandeira (flag) com as lojas na imagem quando não for ALL
        // Ajustado: não altera mais a imagem; apenas retorna o arquivo original.
        async function addFlagToImage(file, roles = ["ALL"]) {
            return file;
        }

        async function uploadTag(file, start, end, comment, roles = ["ALL"]) {
            const fileToUpload = await addFlagToImage(file, roles);
            const storageReference = ref(window.storage, `tags/${Date.now()}_${fileToUpload.name}`);
            await uploadBytes(storageReference, fileToUpload);
            const url = await getDownloadURL(storageReference);

            const docRef = await addDoc(collection(window.db, "tags"), {
                imgUrl: url,
                // Usa datas locais para evitar o shift de timezone
                start: fromYMDLocal(start),
                end: fromYMDLocal(end),
                comment,
                roles,
                createdAt: new Date()
            });

            return { id: docRef.id, imgUrl: url };
        }

        async function fetchTags() {
            const snapshot = await getDocs(collection(window.db, "tags"));
            const results = [];
            snapshot.forEach(docSnap => {
                const data = docSnap.data();
                const start = data.start?.toDate ? data.start.toDate() : data.start;
                const end = data.end?.toDate ? data.end.toDate() : data.end;
                results.push({
                    id: docSnap.id,
                    imgUrl: data.imgUrl,
                    start,
                    end,
                    comment: data.comment || "",
                    roles: data.roles || ["ALL"]
                });
            });
            console.log("Tags do Firebase:", results); // Conferir no console
            return results;
        }

        function renderTags() {
            const grid = document.getElementById("tagsGrid");
            if (!grid) return;
            grid.innerHTML = "";

            tags.forEach((tag, index) => {
                // Normaliza roles para evitar problemas de case
                const tagRoles = (tag.roles || []).map(r => String(r).toUpperCase());
                // Filtro de lojas do modal de criação (já existente)
                // Só aplica se NÃO houver filtro de lojas ativo no modal de Tags
                const filtroLojas = JSON.parse(localStorage.getItem("filtroLojas")) || [];
                const noViewStoreFilter = !Array.isArray(viewFilter.stores) || viewFilter.stores.length === 0;
                if (noViewStoreFilter && filtroLojas.length > 0 && !(tagRoles.includes("ALL") || tagRoles.some(r => filtroLojas.includes(r)))) return;

                // NOVO: Filtro por Data (viewFilter.start/end) - sobreposição de intervalos (robusto com timezone)
                if (viewFilter.start || viewFilter.end) {
                    const tStart = startOfDay(tag.start);
                    const tEnd = endOfDay(tag.end);
                    if (!tStart || !tEnd) {
                        // Datas inválidas na tag: não entram quando há filtro de data
                        return;
                    }
                    const fStart = viewFilter.start ? startOfDay(viewFilter.start) : null;
                    const fEnd = viewFilter.end ? endOfDay(viewFilter.end) : null;

                    if (fStart && fEnd) {
                        // mantém se houver qualquer sobreposição entre [tStart, tEnd] e [fStart, fEnd]
                        const overlap = (tStart <= fEnd) && (tEnd >= fStart);
                        if (!overlap) return;
                    } else if (fStart) {
                        // mantém se o dia fStart estiver dentro do intervalo da tag
                        if (!(tStart <= endOfDay(fStart) && tEnd >= startOfDay(fStart))) return;
                    } else if (fEnd) {
                        if (!(tStart <= endOfDay(fEnd) && tEnd >= startOfDay(fEnd))) return;
                    }
                }

                // NOVO: Filtro por Lojas (viewFilter.stores)
                if (Array.isArray(viewFilter.stores) && viewFilter.stores.length > 0) {
                    // Ao filtrar por lojas específicas, NÃO incluir automaticamente as tags com ALL
                    const match = tagRoles.some(r => viewFilter.stores.includes(r));
                    if (!match) return;
                }

                // Busca rápida por dia (único ou faixa)
                if (!matchesQuickDay(tag)) return;

                const status = getStatus(tag.start, tag.end);
                const imgSrc = tag.imgUrl || "placeholder.png";

                const div = document.createElement("div");
                div.className = "tag";
                div.style.border = `3px solid ${status === "valid" ? "#27ae60" : status === "soon" ? "#f39c12" : "#e74c3c"}`;

                div.innerHTML = `
                    <input type="checkbox" class="tag-checkbox" data-index="${index}">
                    <img src="${imgSrc}" alt="tag">
                    <small>${formatDate(tag.start)} a ${formatDate(tag.end)}</small>
                    <small>Lojas: ${tagRoles.includes("ALL") ? "Todas" : tagRoles.join(", ")}</small>
                    ${tag.comment ? `<div class="comment-bubble"></div><div class="comment-text">${tag.comment}</div>` : ""}
                    <div class="actions">
                        <button title="Deletar" class="delete-btn" data-index="${index}"><i class="fa-solid fa-trash-can" style="color: red;"></i></button>
                        <button title="Informações de impressão" class="info-btn" data-index="${index}"><i class="fa-solid fa-eye"></i></button>
                    </div>
                `;
                grid.appendChild(div);
                const infoBtn = div.querySelector('.info-btn');
                infoBtn?.addEventListener('click', () => {
                    const t = tags[index];
                    if (t) openPrintedInfoModal(t);
                });
            });

            document.querySelectorAll(".delete-btn").forEach(btn => {
                btn.addEventListener("click", async e => {
                    const idx = Number(e.currentTarget.dataset.index);
                    const tag = tags[idx];
                    if (!tag) return;
                    if (!confirm("Deseja realmente deletar esta tag?")) return;
                    await deleteTag(tag.id);
                    tags.splice(idx, 1);
                    renderTags();
                });
            });
        }

        async function deleteTag(id) {
            await deleteDoc(doc(window.db, "tags", id));
        }

        async function renderTagsFromServer() {
            try {
                tags = await fetchTags();
                renderTags();
            } catch (err) {
                console.error("Erro ao buscar tags do Firebase:", err);
            }
        }

        window.initADM = renderTagsFromServer;

        // ---------- Impressões por tag (consulta + cache) ----------
        function parseDateLocalAny(d){
            if (!d) return null;
            if (d.toDate) return d.toDate();
            const dt = new Date(d);
            return isNaN(dt.getTime()) ? null : dt;
        }
        function pad2(n){ return String(n).padStart(2,'0'); }
        function formatDateTimeBR(d){
            const date = parseDateLocalAny(d);
            if (!date) return '-';
            return `${pad2(date.getDate())}/${pad2(date.getMonth()+1)} - ${pad2(date.getHours())}:${pad2(date.getMinutes())}`;
        }
        async function loadPrintedInfoForTag(tagId){
            const key = String(tagId);
            if (printedInfoCache.has(key)) return printedInfoCache.get(key);
            try {
                if (!window.db || !window.getDocs || !window.collection || !window.query || !window.where) return [];
                const q = window.query(window.collection(window.db,'printedTags'), window.where('tagId','==', key));
                const snap = await window.getDocs(q);
                const arr = [];
                snap.forEach(d=>{
                    const data = d.data?.() || d.data();
                    let roleCode = (data?.role || (typeof d.id==='string' && d.id.includes('__') ? d.id.split('__')[0] : '') || '').toUpperCase();
                    const printedAt = data?.printedAt?.toDate ? data.printedAt.toDate() : (data?.printedAt || null);
                    if (roleCode) arr.push({ role: roleCode, printedAt });
                });
                arr.sort((a,b)=>{
                    const ta = a.printedAt ? new Date(a.printedAt).getTime() : 0;
                    const tb = b.printedAt ? new Date(b.printedAt).getTime() : 0;
                    return tb - ta;
                });
                printedInfoCache.set(key, arr);
                return arr;
            } catch(e){
                return [];
            }
        }

        // ---------- Atenção por tag (consulta + toggle) ----------
        async function loadAttentionForTag(tagId){
            const key = String(tagId);
            if (attentionInfoCache.has(key)) return attentionInfoCache.get(key);
            try {
                const q = window.query(window.collection(window.db,'attentionTags'), window.where('tagId','==', key));
                const snap = await window.getDocs(q);
                const set = new Set();
                snap.forEach(d=>{
                    const data = d.data?.() || d.data();
                    const role = (data?.role || (typeof d.id==='string' && d.id.includes('__') ? d.id.split('__')[0] : '') || '').toUpperCase();
                    const att = (data?.attention === undefined) ? true : !!data.attention;
                    if (role && att) set.add(role);
                });
                attentionInfoCache.set(key, set);
                return set;
            }catch(e){ return new Set(); }
        }
        async function setAttention(tagId, roleCode, on){
            const id = String(tagId);
            const roleLower = String(roleCode).toLowerCase();
            const docId = `${roleLower}__${id}`;
            if (on) {
                await window.setDoc(window.doc(window.db,'attentionTags', docId), { role: roleLower, tagId: id, attention: true, attentionAt: new Date() }, { merge: true });
            } else {
                try { await window.deleteDoc(window.doc(window.db,'attentionTags', docId)); } catch(_) {}
            }
            attentionInfoCache.delete(id);
        }

        // ---------- Modal de Impressões ----------
        function ensurePrintedInfoModal(){
            let modal = document.getElementById('printedInfoModal');
            if (modal) return modal;
            modal = document.createElement('div');
            modal.id = 'printedInfoModal';
            modal.className = 'modal';
            modal.innerHTML = `
              <div class="modal-content" style="max-width:720px;">
                <span id="closePrintedInfo" class="close" style="cursor:pointer;">&times;</span>
                <h2 style="margin-top:0;">Impressões da Tag</h2>
                <div id="printedInfoContent" style="margin-top:10px; max-height:60vh; overflow:auto;"></div>
              </div>`;
            document.body.appendChild(modal);
            document.getElementById('closePrintedInfo')?.addEventListener('click', ()=>{ modal.style.display='none'; });
            modal.addEventListener('click', (e)=>{ if (e.target===modal) modal.style.display='none'; });
            return modal;
        }
        async function openPrintedInfoModal(tag){
            const modal = ensurePrintedInfoModal();
            const content = modal.querySelector('#printedInfoContent');
            content.innerHTML = '<div style="opacity:.7;">Carregando...</div>';
            modal.style.display = 'block';

            const [printedList, attentionSet] = await Promise.all([
                loadPrintedInfoForTag(tag.id),
                loadAttentionForTag(tag.id)
            ]);
            const printedMap = new Map(printedList.map(i=>[String(i.role).toUpperCase(), i]));

            const rows = lojas.map(code=>{
                const role = String(code).toUpperCase();
                const printed = printedMap.get(role);
                const att = attentionSet.has(role);
                const datePart = printed ? formatDateTimeBR(printed.printedAt) : '- | -';
                const statusIcon = printed ? '<i class="fa-solid fa-circle-check" style="color:#27ae60"></i>'
                                           : '<i class="fa-solid fa-circle-xmark" style="color:#e74c3c"></i>';
                const attBtn = printed ? '' : `<button class="att-btn" data-role="${role}" style="margin-left:10px; border:none; background:transparent; cursor:pointer;">
                                  <i class="fa-solid fa-circle-exclamation" style="color:${att?'#e67e22':'#bbb'}"></i>
                                </button>`;
                return `<div class="pi-row" style="display:flex; align-items:center; justify-content:space-between; gap:10px; padding:8px 0; border-bottom:1px solid #eee;">
                          <div style="display:flex; align-items:center; gap:10px;">
                            <strong style="min-width:64px;">${role}</strong>
                            <span>${datePart}</span>
                          </div>
                          <div style="display:flex; align-items:center; gap:8px;">
                            ${statusIcon}
                            ${attBtn}
                          </div>
                        </div>`;
            }).join('');
            content.innerHTML = rows || '<div style="opacity:.7;">Sem lojas cadastradas.</div>';

            // Liga os botões de atenção
            content.querySelectorAll('.att-btn')?.forEach(btn=>{
                btn.addEventListener('click', async ()=>{
                    const role = btn.getAttribute('data-role');
                    const isOn = attentionSet.has(role);
                    await setAttention(tag.id, role, !isOn);
                    // Atualiza ícone local
                    const icon = btn.querySelector('i');
                    if (icon) icon.style.color = !isOn ? '#e67e22' : '#bbb';
                    if (!isOn) attentionSet.add(role); else attentionSet.delete(role);
                });
            });
        }

        // Formulário
        const tagForm = document.getElementById("tagForm");
        if (tagForm) {
            tagForm.addEventListener("submit", async e => {
                e.preventDefault();

                const start = document.getElementById("start").value;
                const end = document.getElementById("end").value;
                const comment = document.getElementById("comment").value;
                const files = document.getElementById("img").files;

                // Nova validação para o período
                if (!start || !end) {
                    alert("Selecione o período!");
                    return;
                }

                const selectedStores = Array.from(document.querySelectorAll("#stores input:checked")).map(cb => cb.value);
                const roles = selectedStores.length > 0 ? selectedStores : ["ALL"];

                if (!files.length) return alert("Selecione pelo menos uma imagem!");

                const overlay = document.getElementById('loadingOverlay');
                const submitBtn = tagForm.querySelector('button[type="submit"]');
                try {
                    if (overlay) overlay.style.display = 'flex';
                    if (submitBtn) { submitBtn.disabled = true; submitBtn.style.opacity = '0.7'; }

                    for (const file of files) {
                        const uploaded = await uploadTag(file, start, end, comment, roles);
                        // Mantém no estado local com datas locais (sem UTC shift)
                        tags.unshift({ ...uploaded, start: fromYMDLocal(start), end: fromYMDLocal(end), comment, roles });
                    }

                    renderTags();
                    tagForm.reset();
                    // limpa seleção do período
                    selStart = selEnd = null;
                    rangeInput.value = "";
                } catch (err) {
                    console.error('Erro ao enviar tags:', err);
                    alert('Houve um erro ao enviar as tags. Tente novamente.');
                } finally {
                    if (overlay) overlay.style.display = 'none';
                    if (submitBtn) { submitBtn.disabled = false; submitBtn.style.opacity = ''; }
                }
            });
        }

        // Exibe nomes/quantidade de arquivos escolhidos de forma amigável
        const imgInput = document.getElementById("img");
        const fileInfoEl = document.getElementById("fileInfo");
        if (imgInput && fileInfoEl) {
            imgInput.addEventListener("change", () => {
                const files = Array.from(imgInput.files || []);
                if (!files.length) {
                    fileInfoEl.textContent = "Vazio";
                    return;
                }
                if (files.length === 1) {
                    fileInfoEl.textContent = files[0].name;
                } else {
                    const first = files.slice(0, 2).map(f => f.name).join(", ");
                    const extra = files.length - 2;
                    fileInfoEl.textContent = extra > 0 ? `${first} e +${extra} arquivo(s)` : first;
                }
            });
        }

        // Seleção e exclusão múltipla
        const selectAll = document.getElementById("selectAll");
        const deleteSelectedBtn = document.getElementById("deleteSelected");

        if (selectAll) {
            selectAll.addEventListener("change", () => {
                const checkboxes = document.querySelectorAll(".tag-checkbox");
                checkboxes.forEach(cb => cb.checked = selectAll.checked);
            });
        }

        if (deleteSelectedBtn) {
            deleteSelectedBtn.addEventListener("click", async () => {
                const selectedIndexes = Array.from(document.querySelectorAll(".tag-checkbox:checked")).map(cb => Number(cb.dataset.index));
                if (!selectedIndexes.length) return alert("Nenhuma tag selecionada.");
                if (!confirm("Deseja realmente deletar as tags selecionadas?")) return;

                for (const idx of selectedIndexes.sort((a, b) => b - a)) {
                    const tag = tags[idx];
                    await deleteTag(tag.id);
                    tags.splice(idx, 1);
                }
                renderTags();
            });
        }

        // Modal de filtros
        const openFiltersBtn = document.getElementById("openFilters");
        const closeFiltersBtn = document.getElementById("closeFilters");
        const filtersModal = document.getElementById("filtersModal");
        const applyFiltersBtn = document.getElementById("applyFilters");

        if (openFiltersBtn) openFiltersBtn.addEventListener("click", () => filtersModal.style.display = "block");
        if (closeFiltersBtn) closeFiltersBtn.addEventListener("click", () => filtersModal.style.display = "none");
        if (applyFiltersBtn) applyFiltersBtn.addEventListener("click", () => {
            const selected = Array.from(document.querySelectorAll("#stores input:checked")).map(cb => cb.value);
            localStorage.setItem("filtroLojas", JSON.stringify(selected));
            filtersModal.style.display = "none";
            renderTags();
        });

        // -------------------- NOVO: Modal de filtros da listagem --------------------
        const openTagsFiltersBtn = document.getElementById("openFilters-tags");
        const tagsFilterModal = document.getElementById("tagsFilterModal");
        const closeTagsFiltersBtn = document.getElementById("closeTagsFilters");
        const applyTagsFiltersBtn = document.getElementById("applyTagsFilters");
        const clearTagsFiltersBtn = document.getElementById("clearTagsFilters");
        const tagsFilterStoresDiv = document.getElementById("tagsFilterStores");
        const tagsQuickSearchInput = document.getElementById("tagsQuickSearch");

        // -------------------- Busca rápida por dia (ex.: "07" ou "07 a 10") --------------------
        let quickDayQuery = null; // { type: 'single', d } | { type: 'range', d1, d2 } | null
        function parseDayQuery(raw) {
            if (!raw) return null;
            const s = String(raw).trim().toLowerCase();
            if (!s) return null;
            const range = s.match(/^(\d{1,2})\s*a\s*(\d{1,2})$/i);
            if (range) {
                let d1 = parseInt(range[1], 10);
                let d2 = parseInt(range[2], 10);
                if (isNaN(d1) || isNaN(d2)) return null;
                if (d1 < 1 || d1 > 31 || d2 < 1 || d2 > 31) return null;
                if (d1 > d2) [d1, d2] = [d2, d1];
                return { type: 'range', d1, d2 };
            }
            if (/^\d{1,2}$/.test(s)) {
                const d = parseInt(s, 10);
                if (d >= 1 && d <= 31) return { type: 'single', d };
            }
            return null;
        }
        function dayOf(dateVal) {
            const d = parseToDate(dateVal);
            return d ? d.getDate() : -1;
        }
        function matchesQuickDay(tag) {
            if (!quickDayQuery) return true;
            const sd = dayOf(tag.start);
            const ed = dayOf(tag.end);
            if (quickDayQuery.type === 'single') {
                return sd === quickDayQuery.d || ed === quickDayQuery.d;
            } else if (quickDayQuery.type === 'range') {
                const { d1, d2 } = quickDayQuery;
                return (sd >= d1 && sd <= d2) || (ed >= d1 && ed <= d2);
            }
            return true;
        }
        tagsQuickSearchInput?.addEventListener('input', () => {
            quickDayQuery = parseDayQuery(tagsQuickSearchInput.value);
            renderTags();
        });

        function renderTagsFilterStores() {
            if (!tagsFilterStoresDiv) return;
            tagsFilterStoresDiv.innerHTML = "";
            lojas.forEach(loja => {
                const label = document.createElement("label");
                const cb = document.createElement("input");
                cb.type = "checkbox";
                cb.value = loja;
                // marcar se já estava selecionado no viewFilter
                if (viewFilter.stores.includes(loja)) cb.checked = true;
                label.appendChild(cb);
                label.appendChild(document.createTextNode(loja));
                tagsFilterStoresDiv.appendChild(label);
            });
        }

        function syncModalInputsFromFilter() {
            const fs = document.getElementById("filterStart");
            const fe = document.getElementById("filterEnd");
            // Usa datas locais para evitar shift de timezone
            fs.value = viewFilter.start ? toYMDLocal(new Date(viewFilter.start)) : "";
            fe.value = viewFilter.end ? toYMDLocal(new Date(viewFilter.end)) : "";
            renderTagsFilterStores();
        }

        openTagsFiltersBtn?.addEventListener("click", () => {
            syncModalInputsFromFilter();
            tagsFilterModal.style.display = "block";
        });
        closeTagsFiltersBtn?.addEventListener("click", () => tagsFilterModal.style.display = "none");

        applyTagsFiltersBtn?.addEventListener("click", () => {
            const fs = document.getElementById("filterStart").value;
            const fe = document.getElementById("filterEnd").value;
            // Faz parse local (YYYY-MM-DD -> Date local 00:00)
            viewFilter.start = fs ? fromYMDLocal(fs) : null;
            viewFilter.end = fe ? fromYMDLocal(fe) : null;
            viewFilter.stores = Array.from(document.querySelectorAll("#tagsFilterStores input:checked")).map(cb => cb.value);
            console.log("[TagsFilter] Aplicado:", {
                start: viewFilter.start,
                end: viewFilter.end,
                stores: viewFilter.stores
            });
            tagsFilterModal.style.display = "none";
            renderTags();
        });

        clearTagsFiltersBtn?.addEventListener("click", () => {
            viewFilter.start = null;
            viewFilter.end = null;
            viewFilter.stores = [];
            const fs = document.getElementById("filterStart");
            const fe = document.getElementById("filterEnd");
            if (fs) fs.value = "";
            if (fe) fe.value = "";
            document.querySelectorAll("#tagsFilterStores input[type='checkbox']").forEach(cb => cb.checked = false);
            tagsFilterModal.style.display = "none";
            renderTags();
        });
    </script>
</body>

</html>