<!DOCTYPE html>
<html lang="pt-br">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Painel de Usuário</title>
  <link rel="stylesheet" href="main-style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
    integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="icon" href="/logo/LOGO USER.png" type="image/png">
  <style>
    /* === NOVO LAYOUT (referência novo-layout-adm) === */
    :root {
      --green: #0c6749;
      --green-dark: #095138;
      --bg: #121b1c;
      --panel: #e6f0ec;
      --radius: 14px;
      --font: "NaruSans-Regular", system-ui, Arial, sans-serif;
    }

    body,
    html {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: var(--font);
    }

    * {
      box-sizing: border-box;
    }

    @font-face {
      font-family: 'NaruSans-Bold';
      src: url(/font/NaruSans-Bold.ttf) format('truetype');
      font-weight: bold;
    }

    @font-face {
      font-family: 'NaruSans-Regular';
      src: url(/font/NaruSans-Regular.ttf) format('truetype');
      font-weight: normal;
    }

    /* Topbar compartilhando estilo do ADM */
    .topbar {
      height: 72px;
      width: 100%;
      background: #018e5f;
      display: flex;
      align-items: center;
      gap: 38px;
      padding: 0 52px;
      font-family: 'NaruSans-Bold', sans-serif;
      font-size: 18px;
      text-align: center;
    }

    .topbar .logo img {
      height: 40px;
      width: auto;
      display: block;
    }

    .topbar .user-info {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-left: 10%;
    }

    .topbar .user-info button {
      background: transparent;
      border: none;
      color: #fff;
      font-family: 'NaruSans-Bold', sans-serif;
      font-size: 18px;
      cursor: pointer;
      padding: 14px 44px;
      border-radius: 0 10px 10px 10px;
      transition: .15s;
      position: relative;
    }

    .topbar .user-info button:hover {
      background: #0c6749;
    }

    .topbar .user-info button.active {
      background: #0c6749;
    }

    /* Badge sessão (loja + logout) */
    .session-badge {
      position: absolute;
      right: 18px;
      top: 14px;
      display: flex;
      align-items: center;
      gap: 6px;
      background: #ffffff10;
      color: #fff;
      border: 1px solid #ffffff22;
      border-radius: 34px;
      padding: 8px 14px;
      font-size: 12px;
      backdrop-filter: blur(6px);
    }

    .session-badge .id {
      font-weight: 600;
      font-size: 13px;
    }

    .session-badge .sep {
      opacity: .4;
    }

    .session-badge .logout-btn {
      background: #fff;
      border: none;
      padding: 6px 14px;
      border-radius: 24px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      color: #0c6749;
    }

    .session-badge .logout-btn:hover {
      filter: brightness(.93);
    }

    /* Barra secundária (agora filtros/status/search) */
    /* Filtros dentro da mesma área das tags */
    .second-header {
      display: none;
    }

    .filter-surface {
      background: #e6f0ec;
      border-radius: 18px;
      padding: 18px 28px 16px;
      box-shadow: 0 4px 14px -4px rgba(0, 0, 0, .18);
      display: flex;
      flex-direction: column;
      gap: 14px;
      margin-bottom: 26px;
    }

    .filter-surface.compact {
      position: sticky;
      top: 80px;
    }

    /* (Removido FAB de filtros neste layout) */
    .filters-row {
      display: flex;
      gap: 14px;
      align-items: center;
      flex-wrap: nowrap;
      overflow: hidden;
    }

    .filters-row>* {
      white-space: nowrap;
    }

    .status-filters {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .status-filters button {
      background: #ffffff;
      border: 1px solid #c3d3cb;
      color: #0c6749;
      padding: 10px 18px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
      position: relative;
    }

    .status-filters button.active {
      background: #0c6749;
      color: #fff;
      border-color: #0c6749;
    }

    .status-filters button:not(.active):hover {
      background: #f2f8f5;
    }

    .counts {
      display: flex;
      gap: 18px;
      align-items: center;
      flex-wrap: nowrap;
      font-size: 13px;
      font-weight: 600;
    }

    .counts p {
      margin: 0;
      display: flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
    }

    .dot.green {
      background: #27ae60;
    }

    .dot.orange {
      background: #f39c12;
    }

    .dot.red {
      background: #e74c3c;
    }

    /* Campo busca global */
    .global-search {
      flex: 1;
      position: relative;
    }

    .global-search input {
      width: 100%;
      padding: 12px 14px;
      border: 1px solid #c3d3cb;
      border-radius: 10px;
      background: #fff;
      font-size: 13px;
      font-family: var(--font);
    }

    .global-search input:focus {
      outline: 2px solid #0c6749;
    }

    /* Bulk actions bar (reposicionada) */
    #bulkActions {
      background: #ffffff;
      border: 1px solid #d2e2db;
      padding: 10px 16px;
      border-radius: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 18px;
    }

    #bulkActions .bulk-left {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 13px;
    }

    #bulkActions .bulk-right {
      display: flex;
      gap: 10px;
    }

    .bulk-btn {
      background: #fff;
      border: 1px solid #c3d3cb;
      padding: 8px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .bulk-btn.primary {
      background: #0c6749;
      color: #fff;
      border-color: #0c6749;
    }

    .bulk-btn.primary:hover {
      filter: brightness(.93);
    }

    .bulk-btn:not(.primary):hover {
      background: #f2f8f5;
    }

    /* Layout base: sidebar + conteúdo */
    /* App shell full height */
    .app-shell {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      width: 100%;
      overflow: hidden;
    }

    .main-area {
      flex: 1;
      display: flex;
      min-height: 0;
      /* para scroll interno */
    }

    nav.side-bar {
      width: 250px;
      background: #113330;
      color: #fff;
      padding: 4px 0 28px;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    .sidebar-header {
      font-family: 'NaruSans-Bold', sans-serif;
      padding: 0 16px 10px;
      font-size: 22px;
    }

    .sidebar-search {
      padding: 0 16px 14px;
    }

    .sidebar-search input {
      width: 100%;
      background: #16403c;
      border: 1px solid #2c5b55;
      color: #fff;
      border-radius: 8px;
      font-size: 12px;
      padding: 10px 12px;
      font-family: var(--font);
    }

    .sidebar-search input::placeholder {
      color: #c6d1cc;
      opacity: .6;
    }

    ul#categories-list {
      list-style: none;
      margin: 0;
      padding: 0 4px 0 0;
      flex: 1;
      overflow-y: auto;
    }

    ul#categories-list::-webkit-scrollbar {
      width: 8px;
    }

    ul#categories-list::-webkit-scrollbar-thumb {
      background: #1d4c47;
      border-radius: 20px;
      border: 2px solid #113330;
    }

    ul#categories-list li {
      padding: 10px 18px;
      cursor: pointer;
      font-size: 13px;
      font-family: var(--font);
      border-radius: 8px;
      transition: background .15s, color .15s;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    ul#categories-list li.active,
    ul#categories-list li:hover {
      background: #0c6749;
      color: #fff;
    }

    .category-pill-count {
      font-size: 11px;
      background: #ffffff20;
      padding: 2px 6px;
      border-radius: 12px;
    }

    /* Conteúdo central */
    main.content-wrapper {
      flex: 1;
      padding: 0;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    .content-inner {
      flex: 1;
      overflow: auto;
      padding: 26px 52px 48px;
    }

    .tags-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
      gap: 34px;
    }

    .tag {
      background: #fff;
      border: 2px solid #0c6749;
      border-radius: 14px;
      padding: 18px 20px 16px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      position: relative;
    }

    .tag img {
      width: 100%;
      height: 260px;
      object-fit: cover;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }

    .tag-head {
      position: absolute;
      top: 8px;
      left: 8px;
      right: 8px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .select-row {
      background: #fff;
      padding: 4px;
      border: 2px solid #0c6749;
      border-radius: 8px;
      width: 34px;
      height: 34px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .tag-actions {
      display: flex;
      flex-direction: row;
      gap: 6px;
    }

    .tag-actions button {
      background: #ffffff;
      border: 2px solid #0c6749;
      border-radius: 8px;
      width: 38px;
      height: 38px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #0c6749;
    }

    .tag-actions button:hover {
      background: #0c6749;
      color: #fff;
    }

    .tag small {
      font-size: 11px;
      font-weight: 600;
      letter-spacing: .4px;
    }

    .remove-btn {
      background: #e74c3c;
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 12px;
      cursor: pointer;
      font-weight: 600;
    }

    .remove-btn:hover {
      filter: brightness(.92);
    }

    /* Attention indicator reuse */
    .attention-indicator {
      position: relative;
    }

    /* Counts + filtros container adaptável */
    .top-interactions {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    /* Tag status border colors override when dynamic */
    .tag[ data-status='valid'] {
      --br: #27ae60;
    }

    .tag[ data-status='soon'] {
      --br: #f39c12;
    }

    .tag[ data-status='expired'] {
      --br: #e74c3c;
    }

    /* Quando deletada força preto */
    .tag.deleted {
      border-color: #000 !important;
    }

    /* Modal animations (mantidos) */
    #removeConfirmModal,
    #removeSuccessModal {
      animation: modalFadeIn .3s ease-out;
    }

    @keyframes modalFadeIn {
      from {
        opacity: 0;
        transform: scale(.95);
      }

      to {
        opacity: 1;
        transform: scale(1);
      }
    }
  </style>
</head>

<body>

  <div class="app-shell">
    <!-- HEADER -->
    <header class="topbar">
      <div class="logo"><img src="/logo/PRICEBOARD LOGO.svg" alt="Logo"></div>
      <div class="user-info" id="navButtons">
        <button class="active" data-page="tags">Tag's</button>
        <button data-page="pdfs">PDF's</button>
        <button data-page="margem">Def. Margem</button>
        <button data-page="etiquetas">Etiquetas</button>
      </div>
      <div id="sessionBadge" class="session-badge" style="display:flex;">
        <span class="id" id="badgeUser"></span>
        <span class="sep">•</span>
        <span class="flag" id="badgeRole"></span>
        <button type="button" class="logout-btn" id="logoutTop">Sair</button>
      </div>
    </header>

    <!-- FILTROS (logo abaixo da header, largura total) -->
    <!-- (Removido container separado de filtros; agora dentro da content-inner) -->

    <!-- MAIN AREA: sidebar + tags -->
    <div class="main-area">
      <nav class="side-bar">
        <div class="sidebar-header">Categorias</div>
        <div class="sidebar-search"><input id="searchCategories" type="text" placeholder="Pesquisar"></div>
        <ul id="categories-list"></ul>
      </nav>
      <main class="content-wrapper">
        <div class="content-inner">
          <div class="filter-surface" id="filterSurface">
            <div class="filters-row">
              <div class="status-filters" style="flex-wrap: nowrap;" id="statusFilters">
                <button class="status-filter active" data-status="all"><i class="fa-solid fa-layer-group"></i>
                  Todas</button>
                <button class="status-filter" data-status="valid"><i class="fa-solid fa-circle-check"></i> Adicionar na
                  Loja</button>
                <button class="status-filter" data-status="expired"><i class="fa-solid fa-box-archive"></i> Retirar da
                  Loja</button>
                <button class="status-filter" data-status="printed"><i class="fa-solid fa-print"></i> Impressas</button>
              </div>
              <div class="counts" id="countsBox">
                <p><span class="dot green" title="Disponíveis"></span><span id="countValid">0</span></p>
                <p><span class="dot orange" title="Logo vencem"></span><span id="countSoon">0</span></p>
                <p><span class="dot red" title="Vencidas"></span><span id="countExpired">0</span></p>
                <p title="Total"><strong><span id="countTotal">0</span></strong></p>
              </div>

              <button id="refreshBtn"
                style="background:#0c6749; color:#fff; border:none; padding:10px 18px; border-radius:10px; cursor:pointer; font-size:12px; font-weight:600; display:flex; align-items:center; gap:6px; height:42px;"><i
                  class="fa-solid fa-rotate"></i> Atualizar</button>
            </div>
            <div id="bulkActions" hidden>
              <div class="bulk-left">
                <input type="checkbox" id="selectAllVisible">
                <label for="selectAllVisible">Selecionar visíveis</label>
                <span class="sep">|</span>
                <span class="sel-info"><span id="selectedCount">0</span> selecionadas</span>
                <div class="global-search" style="max-width:340px;">
                  <input id="search" type="text" placeholder="Buscar / dia (ex: 7 ou 07 a 10)">
                </div>
              </div>
              <div class="bulk-right">
                <button type="button" id="bulkDownload" class="bulk-btn"><i class="fa-solid fa-circle-down"></i> Baixar
                  Selecionadas</button>
                <button type="button" id="bulkPrint" class="bulk-btn primary"><i class="fa-solid fa-print"></i> Imprimir
                  Selecionadas</button>
              </div>
            </div>
          </div>
          <div class="tags-grid" id="tagsGrid"></div>
        </div>
      </main>
    </div>
  </div>

  <!-- Modal de Confirmação de Retirada -->
  <div id="removeConfirmModal"
    style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
    <div
      style="background: white; padding: 30px; border-radius: 10px; max-width: 400px; width: 90%; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.3);">
      <div style="margin-bottom: 20px;">
        <i class="fa-solid fa-check-circle" style="font-size: 48px; color: #27ae60; margin-bottom: 15px;"></i>
        <h2 style="margin: 0 0 10px 0; color: #2c3e50;">Confirmar Retirada</h2>
        <p style="margin: 0; color: #7f8c8d;">Confirma que esta tag foi retirada da loja?</p>
        <p style="margin: 10px 0 0 0; font-size: 14px; color: #95a5a6;">Ela será removida da sua visualização.</p>
      </div>
      <div style="display: flex; gap: 10px; justify-content: center;">
        <button id="cancelRemove"
          style="background: #95a5a6; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 14px; transition: all 0.2s ease;">
          <i class="fa-solid fa-xmark"></i> Cancelar
        </button>
        <button id="confirmRemove"
          style="background: #27ae60; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 14px; transition: all 0.2s ease;">
          <i class="fa-solid fa-check"></i> Sim, Retirei
        </button>
      </div>
    </div>
  </div>

  <!-- Modal de Sucesso da Retirada -->
  <div id="removeSuccessModal"
    style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
    <div
      style="background: white; padding: 30px; border-radius: 10px; max-width: 350px; width: 90%; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.3);">
      <div style="margin-bottom: 20px;">
        <i class="fa-solid fa-thumbs-up" style="font-size: 48px; color: #27ae60; margin-bottom: 15px;"></i>
        <h2 style="margin: 0 0 10px 0; color: #2c3e50;">Tag Retirada!</h2>
        <p style="margin: 0; color: #7f8c8d;">A tag foi marcada como retirada com sucesso.</p>
      </div>
      <button id="closeRemoveSuccess"
        style="background: #27ae60; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 14px; transition: all 0.2s ease;">
        <i class="fa-solid fa-check"></i> OK
      </button>
    </div>
  </div>

  <!-- Firebase -->
  <script src="sweetalert-loader.js"></script>
  <script src="jszip-loader.js"></script>
  <!-- Loader jsPDF com fallbacks -->
  <script src="jspdf-loader.js"></script>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
    import { getFirestore, collection, getDocs, doc, setDoc, serverTimestamp, query, where, deleteDoc, getDoc, updateDoc, arrayUnion, enableIndexedDbPersistence, or, and } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyAjzds2ts_R2gqgN2x0p80xq20-6QSAkjY",
      authDomain: "tags-repositores.firebaseapp.com",
      projectId: "tags-repositores",
      storageBucket: "tags-repositores.firebasestorage.app",
      messagingSenderId: "452823969336",
      appId: "1:452823969336:web:09ce09427ee49f46c880cd",
      measurementId: "G-0BLTNKVWVZ"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    // Habilita persistência offline (cache IndexedDB); ignora erro em multi-aba
    try { enableIndexedDbPersistence(db).catch(() => { }); } catch (_) { }
    window.db = db;
    window.collection = collection;
    window.getDocs = getDocs;
    window.doc = doc;
    window.setDoc = setDoc;
    window.deleteDoc = deleteDoc;
    window.serverTimestamp = serverTimestamp;
    window.query = query;
    window.where = where;
    window.getDoc = getDoc;
    window.updateDoc = updateDoc;
    window.arrayUnion = arrayUnion;
    // expõe combinadores para uso no segundo script
    window._or = or;
    window._and = and;
  </script>

  <!-- Script do Usuário -->
  <script type="module">
    const role = localStorage.getItem("role");
    const user = localStorage.getItem("user");

    if (!role || role === "ADM") {
      alert("Acesso não permitido!");
      window.location.href = "index.html";
    }

    // Widget fixo com identificação e logout
    // function createSessionBadge() {
    //   if (document.getElementById("sessionBadge")) return; // evita duplicar
    //   const badge = document.createElement("div");
    //   badge.id = "sessionBadge";
    //   badge.className = "session-badge";
    //   const userLabel = (user || "sem-usuário");
    //   const roleLabel = (role || "-");
    //   badge.innerHTML = `
    //               <span class="id">${userLabel}</span>
    //               <span class="sep">•</span>
    //               <span class="flag">${roleLabel}</span>
    //               <button type="button" class="logout-btn" title="Sair">Sair</button>
    //             `;
    //   document.body.appendChild(badge);
    //   badge.querySelector(".logout-btn")?.addEventListener("click", () => {
    //     try {
    //       localStorage.removeItem("role");
    //       localStorage.removeItem("user");
    //     } catch (_) { }
    //     window.location.href = "index.html";
    //   });
    // }
    // // cria o badge se a sessão é válida (não ADM)
    // if (role && role !== "ADM") createSessionBadge();

    // Header: preenche loja logada e botão de sair
    const storeEl = document.getElementById('storeName');
    if (storeEl) {
      // Mostra o nome da loja (role) ou usuário, nunca "Loja" genérico
      storeEl.textContent = role || user || '';
    }
    document.getElementById('logoutTop')?.addEventListener('click', () => {
      try {
        localStorage.removeItem('role');
        localStorage.removeItem('user');
      } catch (_) { }
      window.location.href = 'index.html';
    });

    let tags = [];
    let printedSet = new Set(); // ids impressos para a loja (role) atual
    let attentionSet = new Set(); // ids marcados com atenção para a loja (role) atual
    const selectedTags = new Set(); // ids selecionados
    // Novo: categorias (ações) derivadas das tags para minimizar leituras
    let categories = []; // { name, count }
    let currentCategory = 'all';
    let currentStatusFilter = 'all';

    // Mapa de role (slug) -> código de loja usado nas tags (conforme padrão do ADM)
    // Adapte conforme necessário se surgirem novas lojas/códigos
    const ROLE_TO_CODE = {
      aguamineral: 'AGM',
      araruama1: 'AR1',
      araruama2: 'AR2',
      arsenal: 'ARS',
      bacaxa1: 'BX1',
      bacaxa2: 'BX2',
      botafogo: 'BOT',
      buzios: 'BZ1',
      cabofrio1: 'CF1',
      cabofrio2: 'CF2',
      casimirodeabreu: 'CAS',
      colubande: 'CLB',
      copacabana: 'CPC',
      cordeirinho: 'COR',
      iguaba: 'IGB',
      inoa: 'INO',
      itaborai: 'ITB',
      jardimcatarina: 'JDC',
      jardimesperanca: 'JDE',
      macae1: 'MC1',
      macae2: 'MC2',
      mage1: 'MG1',
      mage2: 'MG2',
      saojosedoimbassai: 'MAR',
      novacidade: 'NCD',
      riobonito1: 'RB1',
      riobonito2: 'RB2',
      riodoouro: 'RDO',
      maracana: 'MRC',
      // Extras presentes no ADM (nomes prováveis dos roles):
      saopedrodaaldeia: 'SPD',
      tangua: 'TAN',
      trindade: 'TRI',
      unamar: 'UNA'
    };

    function resolveRoleOptions(r) {
      const raw = (r || '').trim();
      const low = raw.toLowerCase();
      const up = raw.toUpperCase();
      const code = ROLE_TO_CODE[low];
      const codeLow = code ? code.toLowerCase() : undefined;
      const opts = new Set([raw, low, up, 'ALL', 'all']);
      if (code) { opts.add(code); opts.add(codeLow); }
      return Array.from(opts);
    }

    function parseDateLocal(dateStr) {
      if (!dateStr) return null;
      const date = dateStr.toDate ? dateStr.toDate() : new Date(dateStr);
      return isNaN(date.getTime()) ? null : date;
    }

    function formatDate(dateStr) {
      const date = parseDateLocal(dateStr);
      if (!date) return "Data inválida";
      const meses = ["JAN", "FEV", "MAR", "ABR", "MAI", "JUN", "JUL", "AGO", "SET", "OUT", "NOV", "DEZ"];
      return `${String(date.getDate()).padStart(2, "0")} ${meses[date.getMonth()]}`;
    }

    function getStatus(start, end) {
      const hoje = new Date(); hoje.setHours(0, 0, 0, 0);
      const inicio = parseDateLocal(start);
      const fim = parseDateLocal(end);
      if (!inicio || !fim) return "expired";
      if (fim < hoje) return "expired";
      if (inicio > hoje) return "soon";
      const diff = Math.ceil((fim - hoje) / (1000 * 60 * 60 * 24));
      if (diff <= 1) return "soon";
      return "valid";
    }

    // Utilidades de data para filtros de consulta
    function startOfToday() { const d = new Date(); d.setHours(0, 0, 0, 0); return d; }
    function daysAgo(n) { const d = startOfToday(); d.setDate(d.getDate() - n); return d; }
    function startOfMonth() { const d = new Date(); d.setDate(1); d.setHours(0, 0, 0, 0); return d; }

    async function fetchTags() {
      if (!window.db || !window.getDocs || !window.collection) {
        console.error('Firebase não inicializado corretamente.');
        return [];
      }
      const rRaw = (role || '').trim();
      if (!rRaw) return [];
      // Usa variações + código de loja (ex.: araruama1 -> AR1)
      const roleOptions = resolveRoleOptions(rRaw);
      const today = startOfToday();
      const twoDaysAgo = daysAgo(2);
      const thirtyDaysAgo = daysAgo(30);

      try {
        // Consulta única com OR combinando as três condições
        const q = window.query(
          window.collection(window.db, 'tags'),
          window.where('roles', 'array-contains-any', roleOptions),
          window._or(
            window.where('end', '>=', twoDaysAgo),
            window._and(
              window.where('end', '<', today),
              window.where('end', '>=', thirtyDaysAgo)
            ),
            window.where('deleted', '==', true)
          )
        );
        const snap = await window.getDocs(q);
        const arr = [];
        snap.forEach(docSnap => {
          const data = docSnap.data();
          arr.push({
            id: docSnap.id,
            imgUrl: data.imgUrl,
            start: data.start?.toDate ? data.start.toDate() : data.start,
            end: data.end?.toDate ? data.end.toDate() : data.end,
            comment: data.comment || "",
            roles: data.roles || ["ALL"],
            createdAt: data.createdAt?.toDate ? data.createdAt.toDate() : data.createdAt,
            deleted: !!data.deleted,
            deletedAt: data.deletedAt?.toDate ? data.deletedAt.toDate() : data.deletedAt,
            action: data.action || data.categoria || ''
          });
        });
        if (arr.length > 0) return arr;
      } catch (e) {
        console.warn('Consulta com OR falhou, usando fallback:', e);
      }

      // Fallback: carrega toda a coleção e filtra no cliente por role e janela de datas
      // (usado em ambientes sem índices ou com docs antigos sem campo roles)
      const snapAll = await window.getDocs(window.collection(window.db, 'tags'));
      const results = [];
      const rLow = rRaw.toLowerCase();
      const rCode = ROLE_TO_CODE[rLow];
      snapAll.forEach(docSnap => {
        const data = docSnap.data();
        const start = data.start?.toDate ? data.start.toDate() : data.start;
        const end = data.end?.toDate ? data.end.toDate() : data.end;
        const roles = Array.isArray(data.roles) ? data.roles.map(v => String(v).toLowerCase()) : ['all'];
        const includeRole = roles.includes('all') || roles.includes(rLow) || (rCode ? roles.includes(rCode.toLowerCase()) : false);
        if (!includeRole) return;
        // aplica mesma lógica de janelas
        const endDate = end instanceof Date ? end : new Date(end);
        const isActive = endDate >= twoDaysAgo;
        const isExpiredRecent = endDate < today && endDate >= thirtyDaysAgo;
        const isDeleted = !!data.deleted;
        if (!(isActive || isExpiredRecent || isDeleted)) return;
        results.push({
          id: docSnap.id,
          imgUrl: data.imgUrl,
          start,
          end,
          comment: data.comment || "",
          roles: data.roles || ["ALL"],
          createdAt: data.createdAt?.toDate ? data.createdAt.toDate() : data.createdAt,
          deleted: !!data.deleted,
          deletedAt: data.deletedAt?.toDate ? data.deletedAt.toDate() : data.deletedAt,
          action: data.action || data.categoria || ''
        });
      });
      return results;
    }

    // Busca os IDs de tags já impressas para a role (loja) atual
    async function fetchPrintedSetForRole() {
      try {
        if (!role) return new Set();
        const r = role.toLowerCase();
        const q = window.query(window.collection(window.db, 'printedTags'), window.where('role', '==', r));
        const snap = await window.getDocs(q);
        const set = new Set();
        snap.forEach(d => {
          const data = d.data?.() || d.data();
          let id = data?.tagId;
          if (!id && typeof d.id === 'string' && d.id.includes('__')) {
            id = d.id.split('__')[1];
          }
          if (id !== undefined && id !== null) set.add(String(id));
        });
        return set;
      } catch (err) {
        console.warn('Falha ao buscar impressas:', err);
        return new Set();
      }
    }

    // Busca os IDs com atenção para a role (loja) atual
    async function fetchAttentionSetForRole() {
      try {
        if (!role) return new Set();
        const r = role.toLowerCase();
        const q = window.query(
          window.collection(window.db, 'attentionTags'),
          window.where('role', '==', r)
        );
        const snap = await window.getDocs(q);
        const set = new Set();
        snap.forEach(d => {
          const data = d.data?.() || d.data();
          const att = (data?.attention === undefined) ? true : !!data.attention;
          let id = data?.tagId;
          if (!id && typeof d.id === 'string' && d.id.includes('__')) {
            id = d.id.split('__')[1];
          }
          if (att && id !== undefined && id !== null) set.add(String(id));
        });
        return set;
      } catch (err) {
        console.warn('Falha ao buscar atenções:', err);
        return new Set();
      }
    }

    // Marca uma ou várias tags como impressas para a role atual
    async function markPrintedMany(ids) {
      try {
        if (!role || !Array.isArray(ids) || !ids.length) return;
        const r = role.toLowerCase();
        const promises = ids.map(async (tid) => {
          const idStr = String(tid);
          const docId = `${r}__${idStr}`;
          try {
            await window.setDoc(window.doc(window.db, 'printedTags', docId), {
              role: r,
              tagId: idStr,
              printedAt: (typeof window.serverTimestamp === 'function') ? window.serverTimestamp() : new Date()
            }, { merge: true });
            printedSet.add(idStr);
            // Se havia atenção para esta loja/tag, remove (badge deve sumir)
            try {
              await window.deleteDoc(window.doc(window.db, 'attentionTags', docId));
              if (typeof attentionSet !== 'undefined' && attentionSet instanceof Set) {
                attentionSet.delete(idStr);
              }
            } catch (_) { }
            // remove de seleção em massa se estiver selecionada
            if (selectedTags.has(idStr)) selectedTags.delete(idStr);
          } catch (e) { /* ignora erro individual, tenta continuar */ }
        });
        await Promise.all(promises);
        // Atualiza doc agregado em lote (minimiza leituras futuras)
        await mergeIntoStoreState({ addPrinted: ids });
        // Re-renderiza para refletir remoção em "Adicionar na Loja"
        reRenderKeepingFilter();
        updateBulkBar();
      } catch (err) {
        console.warn('Falha ao marcar impressas:', err);
      }
    }

    async function ensureJsPDF() {
      if (window.jspdf?.jsPDF) return window.jspdf.jsPDF;
      if (window._loadJsPDF) {
        try { const jsPDF = await window._loadJsPDF; return jsPDF; } catch (_) { }
      }
      throw new Error('jsPDF indisponível');
    }

    // -------- Utilitários CORS-seguros --------
    async function ensureJSZip() {
      if (window.JSZip) return window.JSZip;
      if (window._loadJSZip) {
        try { await window._loadJSZip(); if (window.JSZip) return window.JSZip; } catch (_) { }
      }
      // fallback: aguarda script externo carregar
      if (window.JSZip) return window.JSZip;
      throw new Error('JSZip indisponível');
    }

    async function fetchBlobCors(url) {
      const res = await fetch(url, { mode: 'cors', credentials: 'omit', cache: 'no-store' });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.blob();
    }

    function blobToDataURL(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    function extFromMime(type) {
      if (!type) return 'bin';
      const map = { 'image/jpeg': 'jpg', 'image/png': 'png', 'image/webp': 'webp' };
      return map[type] || 'bin';
    }



    function renderTags(filter = currentStatusFilter, tagsList = tags) {
      currentStatusFilter = filter; // persist
      const grid = document.getElementById("tagsGrid");
      grid.innerHTML = "";
      let countValid = 0, countSoon = 0, countExpired = 0;
      const userRole = role?.toLowerCase(); // corrigido: usar a role da sessão
      const roleOptsLow = new Set(resolveRoleOptions(role).map(v => String(v).toLowerCase()));

      const todayMid = new Date(); todayMid.setHours(0, 0, 0, 0);
      tagsList.forEach(tag => {
        // Ocultar tags com início no futuro (ainda não em vigor)
        const tagStart = parseDateLocal(tag.start);
        if (tagStart && tagStart > todayMid) return;
        // Filtro por categoria (action)
        if (currentCategory !== 'all') {
          const act = (tag.action || '').toString().toLowerCase();
          if (act !== currentCategory.toLowerCase()) return;
        }
        const status = getStatus(tag.start, tag.end);
        const isPrinted = printedSet?.has(String(tag.id));
        const isDeleted = tag.deleted || false;
        const isRemoved = removedTagsSet?.has(String(tag.id));

        // Se a tag foi retirada por esta loja, não mostrar mais
        if (isRemoved) return;

        // Filtro de visualização
        if (filter === 'printed') {
          if (!isPrinted) return;
        } else if (filter === 'valid') {
          // "Adicionar na Loja": NÃO mostrar tags deletadas, mostrar somente as NÃO impressas e não vencidas
          if (isDeleted) return; // Tags deletadas nunca aparecem em "Adicionar na Loja"
          if (isPrinted) return;
          if (status === 'expired') return;
        } else if (filter === 'expired') {
          // "Retirar da Loja": mostrar vencidas OU deletadas
          if (!isDeleted && status !== 'expired') return;
        } else {
          if (filter !== "all" && status !== filter) return;
        }

        const tagRoles = (tag.roles || []).map(r => String(r).toLowerCase());
        const matchThisStore = tagRoles.some(tr => roleOptsLow.has(tr));
        if (!matchThisStore) return;

        // Contagem apenas para tags não deletadas
        if (!isDeleted) {
          if (status === "valid") countValid++;
          else if (status === "soon") countSoon++;
          else countExpired++;
        }

        const div = document.createElement("div");
        div.className = "tag";
        div.dataset.status = status;
        if (isDeleted) div.classList.add('deleted');

        // Define a cor da borda: preto para deletadas, cores normais para as outras
        if (isDeleted) {
          div.style.borderColor = "#000000";
        } else {
          div.style.borderColor = status === "valid" ? "#27ae60" : status === "soon" ? "#f39c12" : "#e74c3c";
        }

        if (!div.style.position) div.style.position = 'relative';

        // Verifica se deve mostrar botão de retirada (tags vencidas ou deletadas)
        const shouldShowRemoveBtn = (status === 'expired' || isDeleted) && filter === 'expired';

        div.innerHTML = `
                    <div class="tag-head">
                      <label class="select-row">
                        <input type="checkbox" class="tag-select" data-id="${tag.id}" ${selectedTags.has(tag.id) ? "checked" : ""}>
                      </label>
                      <div class="tag-actions">
                        ${attentionSet?.has(String(tag.id)) && !isPrinted ? `<span class="attention-indicator" title="Atenção desta tag" style="display:inline-flex;align-items:center;justify-content:center;width:22px;height:22px;border-radius:50%;background:#c92222;color:#fff;margin-top:4px;box-shadow:0 1px 3px rgba(0,0,0,0.25);"><i class='fa-solid fa-exclamation' style='font-size:14px;line-height:1;'></i></span>` : ``}
                        <button type="button" class="action-btn download" title="${isDeleted ? 'Tag removida' : 'Baixar'}" data-id="${tag.id}" ${isDeleted ? 'disabled' : ''}><i class="fa-solid fa-circle-down"></i></button>
                        <button type="button" class="action-btn print" title="${isDeleted ? 'Tag removida' : 'Imprimir'}" data-id="${tag.id}" ${isDeleted ? 'disabled' : ''}><i class="fa-solid fa-print"></i></button>
                      </div>
                    </div>
                    <img src="${tag.imgUrl || 'placeholder.png'}" alt="tag">
                    <small>${formatDate(tag.start)} a ${formatDate(tag.end)}</small>
                    <small>Lojas: ${((tag.roles || []).includes("ALL")) ? "Todas" : (tag.roles || []).join(", ")}</small>
                    ${tag.comment ? `<div class="comment-bubble"></div><div class="comment-text">${tag.comment}</div>` : ""}
                    ${isDeleted ? `<div style="position:absolute;top:5px;right:5px;background:#000;color:#fff;padding:2px 6px;border-radius:3px;font-size:10px;font-weight:bold;">REMOVIDA</div>` : ""}
                    ${shouldShowRemoveBtn ? `<button type="button" class="remove-btn" data-id="${tag.id}"><i class="fa-solid fa-check"></i> Confirmar Retirada</button>` : ""}
                  `;
        grid.appendChild(div);


        // Deixa os ícones verdes quando já foi impressa para esta loja
        if (isPrinted) {
          const dlBtn = div.querySelector('.action-btn.download i');
          const prBtn = div.querySelector('.action-btn.print i');
          dlBtn?.style.setProperty('color', '#27ae60', 'important');
          prBtn?.style.setProperty('color', '#27ae60', 'important');
          const pr = div.querySelector('.action-btn.print');
          pr?.setAttribute('title', 'Impressa');
        }

        // Eventos de UI (visual apenas)
        const checkbox = div.querySelector('.tag-select');
        checkbox?.addEventListener('change', (e) => {
          const id = checkbox.getAttribute('data-id');
          if (checkbox.checked) selectedTags.add(id); else selectedTags.delete(id);
          updateBulkBar();
        });

        // Botões individuais: apenas feedback visual por enquanto
        div.querySelector('.action-btn.download')?.addEventListener('click', async () => {
          if (isDeleted) {
            if (window.Swal) {
              Swal.fire({ icon: 'warning', title: 'Download bloqueado', text: 'Esta tag foi removida e não pode ser baixada!' });
            } else {
              alert('Esta tag foi removida e não pode ser baixada!');
            }
            return;
          }
          const status = window.getStatus(tag.start, tag.end);
          if (status === "expired") {
            if (window.Swal) {
              Swal.fire({ icon: 'warning', title: 'Download bloqueado', text: 'Esta tag está vencida e não pode ser baixada!' });
            } else {
              alert('Esta tag está vencida e não pode ser baixada!');
            }
            return;
          }
          // Download forçado via blob
          try {
            const response = await fetch(tag.imgUrl);
            const blob = await response.blob();
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `tag_${tag.id}.png`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            setTimeout(() => URL.revokeObjectURL(url), 1000);
            // Marca como impressa/baixada para esta loja
            await markPrintedMany([tag.id]);
          } catch (e) {
            alert('Erro ao baixar a imagem.');
          }
        });

        // Novo: imprimir = gerar PDF, baixar e abrir em nova guia
        div.querySelector('.action-btn.print')?.addEventListener('click', async () => {
          if (isDeleted) {
            if (window.Swal) {
              Swal.fire({ icon: 'warning', title: 'Impressão bloqueada', text: 'Esta tag foi removida e não pode ser impressa!' });
            } else {
              alert('Esta tag foi removida e não pode ser impressa!');
            }
            return;
          }
          const status = window.getStatus(tag.start, tag.end);
          if (status === "expired") {
            if (window.Swal) {
              Swal.fire({ icon: 'warning', title: 'Impressão bloqueada', text: 'Esta tag está vencida e não pode ser impressa!' });
            } else {
              alert('Esta tag está vencida e não pode ser impressa!');
            }
            return;
          }
          try {
            const JsPDF = await ensureJsPDF();
            if (!JsPDF) {
              if (window.Swal) {
                await Swal.fire({ icon: 'error', title: 'PDF indisponível', text: 'Aguarde o carregamento do gerador de PDF e tente novamente.' });
              } else {
                alert('Gerador de PDF ainda não carregado.');
              }
              return;
            }
            const resp = await fetch(tag.imgUrl, { cache: 'no-store' });
            const imgBlob = await resp.blob();
            const dataUrl = await new Promise((resolve, reject) => {
              const fr = new FileReader();
              fr.onload = () => resolve(fr.result);
              fr.onerror = reject;
              fr.readAsDataURL(imgBlob);
            });
            const img = await new Promise((resolve) => {
              const im = new Image();
              im.onload = () => resolve(im);
              im.src = dataUrl;
            });
            // Se a tag for específica de loja (não ALL), recorta uma pequena faixa inferior
            const isSpecificStore = Array.isArray(tag.roles) && !tag.roles.includes('ALL');
            let finalDataUrl = dataUrl;
            if (isSpecificStore) {
              const cropRatio = 0; // corta 0% da altura na base
              const cropH = Math.max(1, Math.round(img.height * (1 - cropRatio)));
              const canvas = document.createElement('canvas');
              canvas.width = img.width;
              canvas.height = cropH;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0, img.width, cropH, 0, 0, canvas.width, canvas.height);
              finalDataUrl = canvas.toDataURL(imgBlob.type || 'image/png');
            }
            // Página do PDF ajustada ao tamanho da imagem final (sem bordas)
            const renderImg = await new Promise((resolve) => { const m = new Image(); m.onload = () => resolve(m); m.src = finalDataUrl; });
            const pageWidthPt = renderImg.width;
            const pageHeightPt = renderImg.height;
            const pdf = new JsPDF({ unit: 'pt', format: [pageWidthPt, pageHeightPt] });
            const format = imgBlob.type.includes('jpeg') || imgBlob.type.includes('jpg') ? 'JPEG' : 'PNG';
            pdf.addImage(finalDataUrl, format, 0, 0, pageWidthPt, pageHeightPt);
            const pdfBlob = pdf.output('blob');
            const pdfUrl = URL.createObjectURL(pdfBlob);
            // Abre em nova guia e também baixa
            window.open(pdfUrl, '_blank', 'noopener');
            const a = document.createElement('a');
            a.href = pdfUrl;
            a.download = `tag_${tag.id}.pdf`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            setTimeout(() => URL.revokeObjectURL(pdfUrl), 60000);
            // Marca como impressa
            await markPrintedMany([tag.id]);
          } catch (err) {
            console.error('Falha ao gerar PDF:', err);
            if (window.Swal) {
              Swal.fire({ icon: 'error', title: 'Erro', text: 'Não foi possível gerar o PDF desta tag.' });
            } else {
              alert('Não foi possível gerar o PDF desta tag.');
            }
          }
        });

        // Botão de confirmar retirada
        div.querySelector('.remove-btn')?.addEventListener('click', () => {
          showRemoveConfirmation(tag.id);
        });
      });

      document.getElementById("countValid").textContent = countValid;
      document.getElementById("countSoon").textContent = countSoon;
      document.getElementById("countExpired").textContent = countExpired;
      document.getElementById("countTotal").textContent = countValid + countSoon + countExpired;

      // Atualiza bulk bar ao final da renderização
      updateBulkBar();
      // Atualiza indicador de atenção no filtro "Adicionar na Loja"
      updateAttentionFilterDot();
      // Atualiza indicador de tags deletadas no filtro "Retirar da Loja"
      updateDeletedFilterDot();
    }
    // Expor getStatus e tags para outros scripts
    window.getStatus = getStatus;
    window.tags = tags;

    // Variável para armazenar tags retiradas por esta loja
    let removedTagsSet = new Set();

    // Função para buscar tags retiradas para a role atual
    async function fetchRemovedSetForRole() {
      try {
        if (!role) return new Set();
        const r = role.toLowerCase();
        const q = window.query(window.collection(window.db, 'removedTags'), window.where('role', '==', r));
        const snap = await window.getDocs(q);
        const set = new Set();
        snap.forEach(d => {
          const data = d.data?.() || d.data();
          let id = data?.tagId;
          if (!id && typeof d.id === 'string' && d.id.includes('__')) {
            id = d.id.split('__')[1];
          }
          if (id !== undefined && id !== null) set.add(String(id));
        });
        return set;
      } catch (err) {
        console.warn('Falha ao buscar tags retiradas:', err);
        return new Set();
      }
    }

    // Função para marcar uma tag como retirada
    async function markTagAsRemoved(tagId) {
      try {
        if (!role || !tagId) return;
        const r = role.toLowerCase();
        const idStr = String(tagId);
        const docId = `${r}__${idStr}`;
        await window.setDoc(window.doc(window.db, 'removedTags', docId), {
          role: r,
          tagId: idStr,
          removedAt: (typeof window.serverTimestamp === 'function') ? window.serverTimestamp() : new Date()
        }, { merge: true });
        removedTagsSet.add(idStr);
        // Atualiza doc agregado (minimiza leituras futuras)
        await mergeIntoStoreState({ addRemoved: [idStr] });
      } catch (err) {
        console.warn('Falha ao marcar tag como retirada:', err);
      }
    }

    // -------- Estados agregados por loja (1 leitura) --------
    async function fetchRoleStatesAggregated() {
      if (!role) return null;
      try {
        const r = role.toLowerCase();
        const ref = window.doc(window.db, 'storeState', r);
        const ds = await window.getDoc(ref);
        if (!ds.exists()) return null;
        const data = ds.data();
        const printedIds = Array.isArray(data.printedIds) ? data.printedIds : [];
        const removedIds = Array.isArray(data.removedIds) ? data.removedIds : [];
        const attentionIds = Array.isArray(data.attentionIds) ? data.attentionIds : [];
        return {
          printedSet: new Set(printedIds.map(String)),
          removedSet: new Set(removedIds.map(String)),
          attentionSet: new Set(attentionIds.map(String)),
        };
      } catch (_) { return null; }
    }

    async function mergeIntoStoreState(updates) {
      if (!role) return;
      const r = role.toLowerCase();
      const ref = window.doc(window.db, 'storeState', r);
      try {
        await window.setDoc(ref, { updatedAt: (typeof window.serverTimestamp === 'function') ? window.serverTimestamp() : new Date() }, { merge: true });
        const payload = {};
        if (updates.addPrinted?.length) payload.printedIds = window.arrayUnion(...updates.addPrinted.map(String));
        if (updates.addRemoved?.length) payload.removedIds = window.arrayUnion(...updates.addRemoved.map(String));
        if (updates.addAttention?.length) payload.attentionIds = window.arrayUnion(...updates.addAttention.map(String));
        if (Object.keys(payload).length) await window.updateDoc(ref, payload);
      } catch (_) { /* silencioso */ }
    }

    // -------- Fallback eficiente por IDs visíveis (sem varrer coleção inteira) --------
    function chunk(arr, size) { const out = []; for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size)); return out; }
    async function fetchSetByTagIds(col, ids) {
      if (!ids || !ids.length) return new Set();
      const r = role?.toLowerCase();
      const set = new Set();
      for (const group of chunk(ids, 10)) {
        const q = window.query(
          window.collection(window.db, col),
          window.where('role', '==', r),
          window.where('tagId', 'in', group)
        );
        const snap = await window.getDocs(q);
        snap.forEach(d => {
          const data = d.data?.() || d.data();
          const id = String(data?.tagId ?? (d.id.includes('__') ? d.id.split('__')[1] : ''));
          if (id) set.add(id);
        });
      }
      return set;
    }

    // Cooldown + dedup de requisições de atualização
    let reloadInFlight = null;
    let lastReloadAt = 0;
    const MIN_RELOAD_INTERVAL = 15000; // 15s

    async function reloadAll() {
      if (reloadInFlight) return reloadInFlight;
      const now = Date.now();
      if (now - lastReloadAt < MIN_RELOAD_INTERVAL) {
        if (window.Swal) {
          Swal.fire({ toast: true, position: 'top', timer: 1400, showConfirmButton: false, icon: 'info', title: 'Já atualizado há pouco' });
        }
        return;
      }

      const btn = document.getElementById('refreshBtn');
      const original = btn ? btn.innerHTML : '';
      reloadInFlight = (async () => {
        try {
          if (btn) { btn.disabled = true; btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Atualizando...'; }
          const [tagsRes, aggStates] = await Promise.all([
            fetchTags(),
            fetchRoleStatesAggregated()
          ]);
          tags = tagsRes; window.tags = tags;
          if (aggStates) {
            printedSet = aggStates.printedSet;
            attentionSet = aggStates.attentionSet;
            removedTagsSet = aggStates.removedSet;
          } else {
            const visibleIds = (tags || []).map(t => String(t.id));
            const [pSet, aSet, rSet] = await Promise.all([
              fetchSetByTagIds('printedTags', visibleIds),
              fetchSetByTagIds('attentionTags', visibleIds),
              fetchSetByTagIds('removedTags', visibleIds),
            ]);
            printedSet = pSet; attentionSet = aSet; removedTagsSet = rSet;
          }
          // Atualiza categorias em tempo real após reload
          try {
            const catRef = window.doc(window.db, 'categories', 'global');
            const catSnap = await window.getDoc(catRef);
            if (catSnap.exists()) {
              const data = catSnap.data();
              if (Array.isArray(data.list)) {
                // Recalcula contagens com base nas tags visíveis para a loja
                const mapCounts = new Map();
                (tags || []).forEach(t => { const a = (t.action || t.categoria || '').trim(); if (!a) return; mapCounts.set(a, (mapCounts.get(a) || 0) + 1); });
                categories = data.list.filter(x => x && x.name).map(x => ({ name: x.name, count: (mapCounts.get(x.name) ?? (x.count || 0)) }));
              } else { buildCategories(); }
            } else { buildCategories(); }
            // Re-render lista lateral se já montada
            buildCategories();
          } catch (_) { buildCategories(); }
          reRenderKeepingFilter();
          lastReloadAt = Date.now();
        } catch (err) {
          console.error('Falha ao atualizar:', err);
        } finally {
          if (btn) { btn.disabled = false; btn.innerHTML = original || 'Atualizar'; }
        }
      })();

      try { await reloadInFlight; } finally { reloadInFlight = null; }
    }

    // Função para mostrar o modal de confirmação de retirada
    function showRemoveConfirmation(tagId) {
      const modal = document.getElementById('removeConfirmModal');
      modal.style.display = 'flex';

      const confirmBtn = document.getElementById('confirmRemove');
      const cancelBtn = document.getElementById('cancelRemove');

      // Remove listeners anteriores
      const newConfirmBtn = confirmBtn.cloneNode(true);
      const newCancelBtn = cancelBtn.cloneNode(true);
      confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
      cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

      // Adiciona novos listeners
      newConfirmBtn.addEventListener('click', async () => {
        modal.style.display = 'none';
        try {
          await markTagAsRemoved(tagId);
          showRemoveSuccessModal();
          // Re-renderiza para remover a tag da visualização
          reRenderKeepingFilter();
        } catch (error) {
          console.error('Erro ao confirmar retirada:', error);
          if (window.Swal) {
            Swal.fire({ icon: 'error', title: 'Erro', text: 'Erro ao confirmar retirada. Tente novamente.' });
          } else {
            alert('Erro ao confirmar retirada. Tente novamente.');
          }
        }
      });

      newCancelBtn.addEventListener('click', () => {
        modal.style.display = 'none';
      });

      // Fechar ao clicar fora do modal
      const outsideClickHandler = (e) => {
        if (e.target === modal) {
          modal.style.display = 'none';
          modal.removeEventListener('click', outsideClickHandler);
        }
      };
      modal.addEventListener('click', outsideClickHandler);
    }

    // Função para mostrar o modal de sucesso
    function showRemoveSuccessModal() {
      const modal = document.getElementById('removeSuccessModal');
      modal.style.display = 'flex';

      const closeBtn = document.getElementById('closeRemoveSuccess');

      // Remove listener anterior se existir
      const newCloseBtn = closeBtn.cloneNode(true);
      closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);

      newCloseBtn.addEventListener('click', () => {
        modal.style.display = 'none';
      });

      // Fechar ao clicar fora do modal
      const outsideClickHandler = (e) => {
        if (e.target === modal) {
          modal.style.display = 'none';
          modal.removeEventListener('click', outsideClickHandler);
        }
      };
      modal.addEventListener('click', outsideClickHandler);

      // Auto-fechar após 3 segundos
      setTimeout(() => {
        if (modal.style.display === 'flex') {
          modal.style.display = 'none';
        }
      }, 3000);
    }


    function updateBulkBar() {
      const bar = document.getElementById('bulkActions');
      const selCount = selectedTags.size;
      const selectedCountEl = document.getElementById('selectedCount');
      if (selectedCountEl) selectedCountEl.textContent = String(selCount);
      if (!bar) return;
      if (selCount >= 2) {
        bar.hidden = false;
      } else {
        bar.hidden = true;
      }
    }

    // Mostra uma bolinha vermelha no botão "Adicionar na Loja" quando há alguma TAG com atenção
    function updateAttentionFilterDot() {
      try {
        const btn = document.querySelector('button.filter[data-filter="valid"]');
        if (!btn) return;
        btn.style.position = 'relative';
        // remove dot anterior
        btn.querySelector('.att-dot')?.remove();
        const r = role?.toLowerCase();
        if (!Array.isArray(tags) || !attentionSet || !attentionSet.size) return;
        const hasAttention = tags.some(t => {
          const id = String(t.id);
          if (!attentionSet.has(id)) return false;
          if (printedSet?.has(id)) return false; // já impressa, não alerta
          const st = getStatus(t.start, t.end);
          if (st === 'expired') return false; // vencida não entra em "Adicionar na Loja"
          const tagRoles = (t.roles || []).map(x => String(x).toLowerCase());
          if (!tagRoles.includes('all') && !tagRoles.includes(r)) return false;
          return true;
        });
        if (hasAttention) {
          const dot = document.createElement('span');
          dot.className = 'att-dot';
          Object.assign(dot.style, {
            position: 'absolute',
            top: '-4px',
            right: '-4px',
            width: '10px',
            height: '10px',
            background: '#c92222',
            borderRadius: '50%',
            boxShadow: '0 1px 3px rgba(0,0,0,0.25)'
          });
          dot.title = 'Há tags com atenção para adicionar na loja';
          btn.appendChild(dot);
        }
      } catch (_) { /* silencioso */ }
    }

    // Mostra uma bolinha preta no botão "Retirar da Loja" quando há tags deletadas ou vencidas não retiradas
    function updateDeletedFilterDot() {
      try {
        const btn = document.querySelector('button.filter[data-filter="expired"]');
        if (!btn) return;
        btn.style.position = 'relative';
        // remove dot anterior
        btn.querySelector('.del-dot')?.remove();
        const r = role?.toLowerCase();
        if (!Array.isArray(tags)) return;

        // Verifica se há tags que deveriam aparecer em "Retirar da Loja" e não foram retiradas
        const hasTagsToRemove = tags.some(t => {
          const status = getStatus(t.start, t.end);
          const isDeleted = t.deleted || false;
          const isRemoved = removedTagsSet?.has(String(t.id));

          // Se já foi retirada, não conta
          if (isRemoved) return false;

          // Verifica se é uma tag que deveria estar em "Retirar da Loja"
          const shouldBeInExpired = isDeleted || status === 'expired';
          if (!shouldBeInExpired) return false;

          // Verifica se é para esta loja
          const tagRoles = (t.roles || []).map(x => String(x).toLowerCase());
          if (!tagRoles.includes('all') && !tagRoles.includes(r)) return false;

          return true;
        });

        if (hasTagsToRemove) {
          const dot = document.createElement('span');
          dot.className = 'del-dot';
          Object.assign(dot.style, {
            position: 'absolute',
            top: '-4px',
            right: '-4px',
            width: '10px',
            height: '10px',
            background: '#000000',
            borderRadius: '50%',
            boxShadow: '0 1px 3px rgba(0,0,0,0.25)'
          });
          dot.title = 'Há tags para retirar da loja';
          btn.appendChild(dot);
        }
      } catch (_) { /* silencioso */ }
    }

    function buildCategories() {
      const map = new Map();
      (tags || []).forEach(t => {
        const act = (t.action || '').trim();
        if (!act) return; // ignora vazias
        map.set(act, (map.get(act) || 0) + 1);
      });
      categories = Array.from(map.entries()).sort((a, b) => a[0].localeCompare(b[0])).map(([name, count]) => ({ name, count }));
      const ul = document.getElementById('categories-list');
      if (!ul) return;
      ul.innerHTML = '';
      const addItem = (name, count, key) => {
        const li = document.createElement('li');
        li.textContent = name;
        if (count !== null) {
          const span = document.createElement('span');
          span.className = 'category-pill-count';
          span.textContent = count;
          li.appendChild(span);
        }
        li.dataset.cat = key;
        if (key === currentCategory) li.classList.add('active');
        li.addEventListener('click', () => {
          currentCategory = key;
          ul.querySelectorAll('li').forEach(n => n.classList.remove('active'));
          li.classList.add('active');
          reRenderKeepingFilter();
        });
        ul.appendChild(li);
      };
      addItem('Todas', tags.length, 'all');
      categories.forEach(cat => addItem(cat.name, cat.count, cat.name));
      // Após montar, marcar categorias completas (todas tags impressas para a loja atual)
      try {
        const printed = printedSet || new Set();
        const r = (role || '').toString();
        const byCategory = new Map();
        (tags || []).forEach(t => { const act = (t.action || '').trim(); if (!act) return; if (!byCategory.has(act)) byCategory.set(act, []); byCategory.get(act).push(t); });
        ul.querySelectorAll('li[data-cat]').forEach(li => {
          const key = li.dataset.cat;
          if (key === 'all') return;
          const list = byCategory.get(key) || [];
          if (!list.length) return;
          const allPrinted = list.every(t => printed.has(String(t.id)));
          if (allPrinted) {
            const icon = document.createElement('i');
            icon.className = 'fa fa-circle-check';
            icon.style.color = '#27ae60';
            icon.style.marginLeft = '6px';
            icon.style.fontSize = '14px';
            li.appendChild(icon);
            li.title = 'Todas as tags desta categoria já foram impressas para esta loja';
          }
        });
      } catch (_) { }
    }

    function setupFilterCollapse() {
      const surface = document.getElementById('filterSurface');
      const fab = document.getElementById('filtersFab');
      if (!surface || !fab) return;
      let collapsed = false;
      let lastScrollY = window.scrollY;
      const threshold = 260; // deslocamento antes de colapsar
      function applyState() {
        if (collapsed) {
          surface.style.display = 'none';
          fab.classList.add('visible');
        } else {
          surface.style.display = '';
          fab.classList.remove('visible');
        }
      }
      window.addEventListener('scroll', () => {
        const y = window.scrollY;
        if (!collapsed && y > threshold) { collapsed = true; applyState(); }
        else if (collapsed && y < threshold * 0.6) { collapsed = false; applyState(); }
        lastScrollY = y;
      }, { passive: true });
      fab.addEventListener('click', () => { collapsed = false; applyState(); window.scrollTo({ top: 0, behavior: 'smooth' }); });
    }

    function setupCategorySearch() {
      const input = document.getElementById('searchCategories');
      if (!input) return;
      input.addEventListener('input', () => {
        const term = input.value.trim().toLowerCase();
        const ul = document.getElementById('categories-list');
        ul.querySelectorAll('li').forEach(li => {
          if (li.dataset.cat === 'all') return; // sempre mostra 'Todas'
          const text = li.textContent.toLowerCase();
          li.style.display = text.includes(term) ? '' : 'none';
        });
      });
    }

    function wireStatusFilters() {
      document.querySelectorAll('.status-filter').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.status-filter').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          currentStatusFilter = btn.dataset.status || 'all';
          renderTags(currentStatusFilter);
        });
      });
    }

    async function init() {
      try {
        await reloadAll();
      } catch (err) {
        console.error('Falha ao carregar tags inicialmente:', err);
      }
      // Tenta usar documento agregado de categorias (1 leitura). Espera doc: categories/global { list: [{name,count}] }
      try {
        const catRef = window.doc(window.db, 'categories', 'global');
        const catSnap = await window.getDoc(catRef);
        if (catSnap.exists()) {
          const data = catSnap.data();
          if (Array.isArray(data.list)) {
            categories = data.list.filter(x => x && x.name).map(x => ({ name: x.name, count: x.count || 0 }));
            // Ajusta contagens com base nas tags já filtradas para a loja (sincroniza caso divergente)
            const mapCounts = new Map();
            (tags || []).forEach(t => { const a = (t.action || '').trim(); if (!a) return; mapCounts.set(a, (mapCounts.get(a) || 0) + 1); });
            categories = categories.map(c => ({ name: c.name, count: mapCounts.get(c.name) ?? c.count }));
          } else {
            buildCategories();
          }
        } else {
          buildCategories();
        }
      } catch (_) { buildCategories(); }
      setupCategorySearch();
      wireStatusFilters();

      // Preenche badge com role
      try {
        const bUser = document.getElementById('badgeUser');
        const bRole = document.getElementById('badgeRole');
        if (bUser) bUser.textContent = (user || role || '').toString();
        if (bRole) bRole.textContent = (role || '').toString();
      } catch (_) { }

      // Lógica de colapso do filtro -> FAB
      setupFilterCollapse();

      // Selecionar visíveis (toggle)
      document.getElementById('selectAllVisible')?.addEventListener('change', (e) => {
        const grid = document.getElementById('tagsGrid');
        const boxes = grid.querySelectorAll('.tag-select');
        const check = e.target.checked;
        boxes.forEach(b => {
          const id = b.getAttribute('data-id');
          b.checked = check;
          if (check) selectedTags.add(id); else selectedTags.delete(id);
        });
        updateBulkBar();
      });
      // Botão Atualizar (sem polling)
      document.getElementById('refreshBtn')?.addEventListener('click', reloadAll);
    }
    init();

    // Registro do botão "Baixar Selecionadas" (fora do render e sem depender do DOMContentLoaded já ter disparado)
    function registerBulkDownloadListener() {
      const bulkBtn = document.getElementById('bulkDownload');
      if (!bulkBtn) return;
      if (bulkBtn._zipListener) return; // evita múltiplos listeners
      bulkBtn._zipListener = true;
      bulkBtn.addEventListener('click', async () => {
        // feedback visual
        const originalText = bulkBtn.innerHTML;
        bulkBtn.disabled = true;
        bulkBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Preparando ZIP...';
        try {
          const JSZip = await ensureJSZip();
          const grid = document.getElementById('tagsGrid');
          const boxes = grid.querySelectorAll('.tag-select:checked');
          if (!boxes.length) {
            if (window.Swal) {
              await Swal.fire({ icon: 'warning', title: 'Nenhuma selecionada', text: 'Selecione ao menos uma tag para baixar.' });
            } else {
              alert('Selecione ao menos uma tag para baixar.');
            }
            return;
          }
          // Bloqueio se alguma selecionada for REMOVIDA
          let hasRemovida = false;
          for (const box of boxes) {
            const id = box.getAttribute('data-id');
            const tag = (window.tags || tags).find(t => String(t.id) === String(id));
            if (tag && tag.deleted) { hasRemovida = true; break; }
          }
          if (hasRemovida) {
            if (window.Swal) {
              await Swal.fire({ icon: 'error', title: 'Ação bloqueada', text: 'Uma ou mais tags selecionadas foram removidas e não podem ser baixadas.' });
            } else {
              alert('Uma ou mais tags selecionadas foram removidas e não podem ser baixadas.');
            }
            return;
          }
          let bloqueadas = 0;
          const zip = new JSZip();
          const successIds = [];
          let countAdded = 0;
          for (const box of boxes) {
            const id = box.getAttribute('data-id');
            const tag = (window.tags || tags).find(t => String(t.id) === String(id));
            if (!tag) continue;
            const status = window.getStatus(tag.start, tag.end);
            if (status === 'expired') { bloqueadas++; continue; }
            try {
              const blob = await fetchBlobCors(tag.imgUrl);
              const ext = extFromMime(blob.type) || 'png';
              zip.file(`tag_${tag.id}.${ext}`, blob);
              countAdded++;
              successIds.push(tag.id);
            } catch (_) { /* ignora erro individual */ }
          }
          if (countAdded > 0) {
            const content = await zip.generateAsync({ type: 'blob' });
            const url = URL.createObjectURL(content);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'tags_selecionadas.zip';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            setTimeout(() => URL.revokeObjectURL(url), 60000);
            await markPrintedMany(successIds);
          } else {
            if (window.Swal) {
              await Swal.fire({ icon: 'info', title: 'Nada para baixar', text: 'Nenhuma tag válida selecionada.' });
            } else {
              alert('Nenhuma tag válida selecionada.');
            }
          }
          if (bloqueadas) {
            const msg = `${bloqueadas} tag(s) vencida(s) não foram baixadas.`;
            if (window.Swal) { await Swal.fire({ icon: 'warning', title: 'Algumas não baixadas', text: msg }); } else { alert(msg); }
          }
        } finally {
          bulkBtn.disabled = false;
          bulkBtn.innerHTML = originalText;
        }
      });
    }
    if (document.readyState === 'loading') {
      window.addEventListener('DOMContentLoaded', registerBulkDownloadListener);
    } else {
      registerBulkDownloadListener();
    }

    // Registro do botão "Imprimir Selecionadas": gera PDFs em lotes para evitar estouro de memória
    function registerBulkPrintListener() {
      const btn = document.getElementById('bulkPrint');
      if (!btn) return;
      if (btn._bulkPrint) return;
      btn._bulkPrint = true;
      btn.addEventListener('click', async () => {
        const JsPDF = await ensureJsPDF();
        if (!JsPDF) {
          if (window.Swal) {
            await Swal.fire({ icon: 'error', title: 'PDF indisponível', text: 'Aguarde o carregamento do gerador de PDF e tente novamente.' });
          } else {
            alert('Gerador de PDF ainda não carregado.');
          }
          return;
        }
        const original = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Preparando...';
        try {
          const selected = Array.from(selectedTags);
          if (!selected.length) {
            if (window.Swal) {
              await Swal.fire({ icon: 'warning', title: 'Nenhuma selecionada', text: 'Selecione ao menos uma tag para imprimir.' });
            } else {
              alert('Selecione ao menos uma tag para imprimir.');
            }
            return;
          }
          // Bloqueio se alguma selecionada for REMOVIDA
          let hasRemovida = false;
          for (const id of selected) {
            const tag = (window.tags || tags).find(t => String(t.id) === String(id));
            if (tag && tag.deleted) { hasRemovida = true; break; }
          }
          if (hasRemovida) {
            if (window.Swal) {
              await Swal.fire({ icon: 'error', title: 'Ação bloqueada', text: 'Uma ou mais tags selecionadas foram removidas e não podem ser impressas.' });
            } else {
              alert('Uma ou mais tags selecionadas foram removidas e não podem ser impressas.');
            }
            return;
          }

          // Apenas válidas (não expiradas) para impressão
          const validIds = selected.filter(id => {
            const tag = (window.tags || []).find(t => String(t.id) === String(id));
            if (!tag) return false;
            const status = window.getStatus(tag.start, tag.end);
            return status !== 'expired';
          });
          if (!validIds.length) {
            if (window.Swal) {
              await Swal.fire({ icon: 'info', title: 'Nada para imprimir', text: 'Todas as selecionadas estão vencidas.' });
            } else {
              alert('Todas as selecionadas estão vencidas.');
            }
            return;
          }

          // Gera em lotes para evitar erro "Array.join: Invalid string length"
          const MAX_PER_PDF = 70; // ajuste fino conforme memória do dispositivo
          const groups = chunk(validIds, MAX_PER_PDF);
          const allSuccessIds = [];

          // Função utilitária para baixar um Blob
          const downloadBlob = (blob, fname) => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = fname; document.body.appendChild(a); a.click(); document.body.removeChild(a);
            setTimeout(() => URL.revokeObjectURL(url), 60000);
          };

          for (let gi = 0; gi < groups.length; gi++) {
            const part = groups[gi];
            btn.innerHTML = `<i class="fa-solid fa-spinner fa-spin"></i> Gerando lote ${gi + 1}/${groups.length}...`;
            let pdf = null;
            let pagesAdded = 0;
            for (let i = 0; i < part.length; i++) {
              const id = part[i];
              const tag = (window.tags || []).find(t => String(t.id) === String(id));
              if (!tag) continue;
              try {
                const resp = await fetch(tag.imgUrl, { cache: 'no-store' });
                const blob = await resp.blob();
                const dataUrl = await new Promise((resolve, reject) => {
                  const fr = new FileReader(); fr.onload = () => resolve(fr.result); fr.onerror = reject; fr.readAsDataURL(blob);
                });
                const img = await new Promise((resolve) => { const im = new Image(); im.onload = () => resolve(im); im.src = dataUrl; });
                const isSpecificStore = Array.isArray(tag.roles) && !tag.roles.includes('ALL');
                let finalDataUrl = dataUrl;
                if (isSpecificStore) {
                  const cropRatio = 0.10; // corta 10% da base quando específico da loja
                  const cropH = Math.max(1, Math.round(img.height * (1 - cropRatio)));
                  const canvas = document.createElement('canvas');
                  canvas.width = img.width;
                  canvas.height = cropH;
                  const ctx = canvas.getContext('2d');
                  ctx.drawImage(img, 0, 0, img.width, cropH, 0, 0, canvas.width, canvas.height);
                  finalDataUrl = canvas.toDataURL(blob.type || 'image/png');
                }
                const renderImg = await new Promise((resolve) => { const m = new Image(); m.onload = () => resolve(m); m.src = finalDataUrl; });
                const pageW = renderImg.width;
                const pageH = renderImg.height;
                const format = (blob.type && (blob.type.includes('jpeg') || blob.type.includes('jpg'))) ? 'JPEG' : 'PNG';
                if (!pdf) {
                  pdf = new JsPDF({ unit: 'pt', format: [pageW, pageH] });
                } else {
                  pdf.addPage([pageW, pageH]);
                }
                pdf.addImage(finalDataUrl, format, 0, 0, pageW, pageH);
                pagesAdded++;
                allSuccessIds.push(tag.id);
              } catch (_) { /* ignora erro individual e segue */ }
            }
            if (pagesAdded > 0 && pdf) {
              // Usa arraybuffer para reduzir riscos de estouro de string
              const ab = pdf.output('arraybuffer');
              const blob = new Blob([ab], { type: 'application/pdf' });
              const fname = groups.length > 1 ? `tags_selecionadas_parte_${String(gi + 1).padStart(2, '0')}.pdf` : 'tags_selecionadas.pdf';
              downloadBlob(blob, fname);
            }
          }

          if (!allSuccessIds.length) {
            if (window.Swal) {
              await Swal.fire({ icon: 'info', title: 'Nada para imprimir', text: 'Nenhuma tag válida selecionada.' });
            } else {
              alert('Nenhuma tag válida selecionada.');
            }
            return;
          }
          // Marca como impressas todas as que foram realmente adicionadas
          await markPrintedMany(allSuccessIds);
        } finally {
          btn.disabled = false;
          btn.innerHTML = original;
        }
      });
    }
    if (document.readyState === 'loading') {
      window.addEventListener('DOMContentLoaded', registerBulkPrintListener);
    } else {
      registerBulkPrintListener();
    }

    // Reaplica a visão atual conforme filtro/search/recentes
    function reRenderKeepingFilter() {
      const searchInput = document.getElementById('search');
      const raw = (searchInput?.value || '').trim();
      if (raw) {
        const term = raw.toLowerCase();
        const dayMatch = /^\d{1,2}$/.test(term) ? parseInt(term, 10) : null;
        const range = parseDayRange(term);
        const filtered = (tags || []).filter(tag => {
          const textMatch = (tag.comment || "").toLowerCase().includes(term) ||
            (tag.roles || []).some(r => r.toLowerCase().includes(term));
          if (dayMatch !== null && dayMatch >= 1 && dayMatch <= 31) {
            if (dayMatches(tag, dayMatch)) return true;
          }
          if (range) {
            const s = parseDateLocal(tag.start);
            const e = parseDateLocal(tag.end);
            const sd = s ? s.getDate() : -1;
            const ed = e ? e.getDate() : -1;
            if ((sd >= range.d1 && sd <= range.d2) || (ed >= range.d1 && ed <= range.d2)) return true;
          }
          return textMatch;
        });
        renderTags('all', filtered);
        return;
      }
      const recentBtn = document.getElementById('Recentes');
      if (recentBtn && recentBtn.classList.contains('active')) {
        const hoje = new Date(); hoje.setHours(0, 0, 0, 0);
        const hojeTags = (tags || []).filter(tag => {
          const created = parseDateLocal(tag.createdAt);
          if (!created) return false;
          created.setHours(0, 0, 0, 0);
          return created.getTime() === hoje.getTime();
        });
        renderTags('all', hojeTags.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)));
        return;
      }
      const activeBtn = document.querySelector('.filter.active');
      const activeFilter = activeBtn?.dataset?.filter || 'all';
      renderTags(activeFilter);
    }

    // (Removidos filtros laterais antigos)

    const searchInput = document.getElementById("search");
    function dayMatches(tag, day) {
      const s = parseDateLocal(tag.start);
      const e = parseDateLocal(tag.end);
      const sd = s ? s.getDate() : -1;
      const ed = e ? e.getDate() : -1;
      return sd === day || ed === day;
    }
    function parseDayRange(term) {
      const m = term.match(/^(\d{1,2})\s*a\s*(\d{1,2})$/i);
      if (!m) return null;
      let d1 = parseInt(m[1], 10), d2 = parseInt(m[2], 10);
      if (isNaN(d1) || isNaN(d2)) return null;
      if (d1 < 1 || d1 > 31 || d2 < 1 || d2 > 31) return null;
      if (d1 > d2) { const t = d1; d1 = d2; d2 = t; }
      return { d1, d2 };
    }
    searchInput?.addEventListener("input", () => {
      const raw = searchInput.value.trim();
      const term = raw.toLowerCase();
      if (!term) { renderTags(); return; }
      // Se o usuário digitar apenas o dia (1-31, com ou sem zero à esquerda), filtra por validade (início ou fim)
      const dayMatch = /^\d{1,2}$/.test(term) ? parseInt(term, 10) : null;
      const range = parseDayRange(term);
      const filtered = tags.filter(tag => {
        const textMatch = (tag.comment || "").toLowerCase().includes(term) ||
          (tag.roles || []).some(r => r.toLowerCase().includes(term));
        if (dayMatch !== null && dayMatch >= 1 && dayMatch <= 31) {
          if (dayMatches(tag, dayMatch)) return true;
        }
        if (range) {
          const s = parseDateLocal(tag.start);
          const e = parseDateLocal(tag.end);
          const sd = s ? s.getDate() : -1;
          const ed = e ? e.getDate() : -1;
          if ((sd >= range.d1 && sd <= range.d2) || (ed >= range.d1 && ed <= range.d2)) return true;
        }
        return textMatch;
      });
      renderTags("all", filtered);
    });

    function imprimirTags() {
      // Lógica para imprimir todas as tags, exceto as vencidas
      const todasTags = document.querySelectorAll('.tag'); // Supondo que as tags tenham a classe 'tag'
      const tagsVencidas = [...todasTags].filter(tag => !tag.classList.contains('vencida')); // Filtra as tags vencidas

      if (tagsVencidas.length > 0) {
        // Lógica para imprimir as tags
        // ...código de impressão...

      }
    }
  </script>
</body>

</html>